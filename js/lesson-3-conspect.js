// Модуль 3 - Объекты
// ****************************************************************************************

// Примеры из конспекта

// ========================================================================================
// Создание объекта - с использованием фигурных скобок
// ========================================================================================
// Свойства описываются парой  КЛЮЧ : Значение
// ----------------------------------------------------------------------------------------
const book = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};
console.log(book);
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Вложенные свойства
// ========================================================================================
// Значением свойства может быть другой объект, для того,
// чтобы сохранять вложенные и сгруппированные данные (фигурные скобки)
// ----------------------------------------------------------------------------------------
const user = {
  name: "Jacques Gluke",
  tag: "jgluke",
  location: {
    country: "Jamaica",
    city: "Ocho Rios",
  },
  stats: {
    followers: 5603,
    views: 4827,
    likes: 1308,
    },
  hobbies: ["swiming", "music", "sci-fi"],
};
console.log(user);
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Получение доступа к свойству объекта ( первый способ )
// ========================================================================================
// объект.имя_свойства
// Синтаксис «через точку» используется в большинстве случаев. Используется,
// когда заблаговременно знаем имя (ключ) свойства, к которому нужен доступ
// ----------------------------------------------------------------------------------------
console.log(book.author);          // Bernard Cornwell
console.log(book.genres);          // ['historical prose', 'adventure']
console.log(user.name);            // Jacques Gluke
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Обращение к вложенным свойствам 
// ========================================================================================
// Используется цепочка обращений «через точку»  
// ----------------------------------------------------------------------------------------
console.log(user.stats.likes);     // 1308
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Если значение свойства - массив :
// ========================================================================================
// Используется цепочка обращений «через точку» 
// Далее доступ к элементам - через квадратные скобки и индекс
// ----------------------------------------------------------------------------------------
const hobbies = user.hobbies;
console.log(hobbies); // ['swiming', 'music', 'sci-fi']
// Первый элемент (с индексом 0)
const firstHobby = user.hobbies[0];
console.log(firstHobby); // 'swiming'
// Длина массива
const numberOfHobbies = user.hobbies.length;
console.log(numberOfHobbies); // 3
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Получение доступа к свойству объекта ( второй способ ):
// ========================================================================================
// Обращение через "квадратные скобки".
// В квадратных скобках - строка с названием свойства
// объект["имя свойства"]. 
// Возвращает значение свойства с таким именем.
// Используется, когда имя свойства заранее неизвестно
// или сохраняется в переменной, например, как значение параметра функции.
// ----------------------------------------------------------------------------------------
const bookTitle = book["title"];
console.log(bookTitle); // 'The Last Kingdom'

const bookGenres = book["genres"];
console.log(bookGenres); // ['historical prose', 'adventurs']

const propKey = "author";
const bookAuthor = book[propKey];
console.log(bookAuthor); // 'Bernard Cornwell'
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Изменение значения свойства
// ========================================================================================
// Необходимо обратиться к свойству (через точку или через квадратные скобки)
// и присвоить новое значение
// ----------------------------------------------------------------------------------------
book.rating = 9;
book.isPublic = false;
book.genres.push("драма");

console.log(book.rating); // 9
console.log(book.isPublic); // false
console.log(book.genres); // ['historical prose', 'adventures', 'драма']
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Добавление нового свойства для объекта
// ========================================================================================
// Не отличается от присваивания значения существующему свойству.
// Если свойства нет, то новое свойство добавляется к объекту со значением.
// ----------------------------------------------------------------------------------------
book.pageCount = 836;
book.originalLanguage = "en";
book.translations = ["ua", "ru"];

console.log(book.pageCount);        // 836
console.log(book.originalLanguage); // 'en'
console.log(book.translations);     // ['ua', 'ru']
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Краткие свойства  (shorthand properties)
// ========================================================================================
// Если значение необходимо взять из переменной или параметра функции
// с таким же именем, как и у свойства.
// Объявляя объект, достаточно указать только имя свойства,
// а значение будет взято из переменной с аналогичным именем.
// ----------------------------------------------------------------------------------------
const descr = "Уведомление";
const time = 25;

const letter = {
  descr,
  time,
};

console.log(letter); 
console.log(letter.descr); // "Уведомление"
console.log(letter.time); // 25
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Расчетные свойства
// ========================================================================================
// Если необходимо в объявление объекта дать свойство, имя которого в переменной
// ----------------------------------------------------------------------------------------
const propName = "name";

const child = {
  age: 12,
  // Имя этого свойства будет взять из переменной propName
  [propName]: "Оля",
};

console.log(child);
console.log(child.name); // 'Оля'
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Методы объекта
// ========================================================================================
// Объектя могут содержать не только данные, но и функции работы с этими данными
// Если значение свойства - функция, это свойстыо называется методом объекта
// Такие объекты называются МОДЕЛИ
// ----------------------------------------------------------------------------------------
// ✅ Логично и синтаксично сгруппированные сущности
const bookShelf = {
  books: ["The Last Kingdom", "Dream Guardian"],
  // Это метод объекта
  getBooks() {
    console.log("Этот метод вернет все книни - свойство  books");
  },
  // Это метод объекта
  addBook(bookName) {
      console.log(`Этот метод добавит книгу ${bookName} в свойство  books`);
  },
};

// Вызовы методов
bookShelf.getBooks();
bookShelf.addBook("Абрикос");
console.log(bookShelf);
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Доступ к свойствам объекта в методах
// ========================================================================================
// Методы используются для работы со свойствами объекта, их изменения
// Для доступа к объекту в методе ставится не название объекта,
// а ключевое слово  this  = объект, который вызвал этот метод
// ----------------------------------------------------------------------------------------
const biblio = {
    books: ["The Last Kingdom"],
    // Список книг
  getBooks() {
    return this.books;
    },
  // Добавление книги
  addBook(bookName) {
    this.books.push(bookName);
    },
  // Удаление книги
  removeBook(bookName) {
    const bookIndex = this.books.indexOf(bookName);
    this.books.splice(bookIndex, 1);
  },
};
// Список книг
console.log(biblio.getBooks()); // ["The Last Kingdom"]
// Добавление книг
biblio.addBook("The Mist");
biblio.addBook("Dream Guardian");
// Удаление книги
console.log(biblio.getBooks()); // ['The Last Kingdom', 'The Mist', 'Dream Guardian']
biblio.removeBook("The Mist");
// Список книг
console.log(biblio.getBooks()); // ['The Last Kingdom', 'Dream Guardian']
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Переборка объекта
// ========================================================================================
// Используется цикл for...in, который перебирает ключи (key) объекта (object)
// for (key in object) {  }
// ----------------------------------------------------------------------------------------
for (const key in book) {
  // Ключ
  console.log(key);
  // Значение свойства с таким ключем
  console.log(book[key]);
}
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод  Object.create(имя_базового_объекта)
// ========================================================================================
// Создается новый объект,
// связывая его со свойствами (и значениями свойств) базового объекта
// При этом в самом объекте этих свойств нет.
// Доступ к ним есть также "через точку", как к собственным свойствам
// ----------------------------------------------------------------------------------------
// Базовый объект
const animal = {
  legs: 4,
};
// Создание нового объекта на основе  animal
const dog = Object.create(animal);
// Новое свойство объекта   dog
dog.name = "Манго";

console.log('Объект dog = ',dog);       // {name: 'Манго'}
console.log('dog.name - ',dog.name);  // 'Манго'
// leg=4 не является свойством dog.
// Это свойство объекта-прототипа  animal.
console.log('dog.legs - ',dog.legs);  // 4

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод объекта  hasOwnProperty()
// ========================================================================================
// СИНТАКСИС :    имя_объекта.hasOwnProperty("имя_свойства")
// Для того, чтобы узнать, содержит ли объект собственное свойство, 
// используется метод hasOwnProperty(key), который возвращает true или false.
// ----------------------------------------------------------------------------------------
// ✅ Возвращает true только для собственных свойств
console.log(dog.hasOwnProperty("name")); // true
console.log(dog.hasOwnProperty("legs")); // false

// Цикл по for...in
for (const key in dog) {
  // Если это собственное свойство - Выводим его со значением
  if (dog.hasOwnProperty(key)) {
    console.log(`Собственное свойство - ${key} = ${dog[key]}` );
  } else {
    // Если НЕ собственное свойство - Выводим сообщение   
    console.log(`НЕ собственное свойство - ${key}` );
  }
}
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод   Object.keys(имя_объекта)
// ========================================================================================
// Принимает объект и возвращает массив ключей его собственных свойств
// Если у объекта нет собственных свойств - возвращает пустой массив
// ----------------------------------------------------------------------------------------
const keys1 = Object.keys(book);
console.log(keys1); // ['title', 'author', 'genres', 'isPublic', 
         // 'rating', 'pageCount', 'originalLanguage', 'translations']

const keys2 = Object.keys(dog);
console.log(keys2); // ['name']
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Перечисление ключей в цикле for...of
// ========================================================================================
// Перед циклом получаем массив собственных ключей
// ----------------------------------------------------------------------------------------
const keysOwn = Object.keys(dog);
for (let keyMy of keysOwn) {
    console.log(`Собственное свойство - ${keyMy} = ${dog[keyMy]}`);
}
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод  Object.values(имя_объекта)​
// ========================================================================================
// Принимает объект и возвращает массив ЗНАЧЕНИЙ его собственных свойств
// Если у объекта нет собственных свойств - возвращает пустой массив
// ----------------------------------------------------------------------------------------
const values1 = Object.values(book);
console.log(values1); // Есть и вложенные массивы, если свойства-массивы :
// ['The Last Kingdom', 'Bernard Cornwell', ['historical prose', 'adventure',
//  'драма'], false, 9, 836, 'en', ['ua', 'ru'] ]
const values2 = Object.values(dog);
console.log(values2); //  ['Манго']
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Перечисление ЗНАЧЕНИЙ в цикле for...of
// ========================================================================================
// Перед циклом получаем массив ЗНАЧЕНИЙ собственных свойств
// ----------------------------------------------------------------------------------------
const goods = {
  apples: 6,
  grapes: 3,
  bread: 4,
  cheese: 7,
};
// Перед циклом получаем массив ЗНАЧЕНИЙ собственных свойств
const values3 = Object.values(goods); // [6, 3, 4, 7]
// Сумма товаров
let total = 0;
// Расчет суммы количества всех товаров
for (const value of values3) {
  total += value;
}

console.log(total); // 20
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод  Object.entries(имя_объекта)​
// ========================================================================================
// Возвращает массив, каждый элемент которого будет еще одним массивом
// из 2-х елементов: имени СОБСТВЕННОГО свойства и значения этого свойства
// ----------------------------------------------------------------------------------------
const entriesDog = Object.entries(dog);
console.log('entriesDog - ',entriesDog); // [ ['name', 'Манго'] ]
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Массив объектов
// ========================================================================================
// Обычно используется массив однотипных объектов, 
// с одинаковыми названиями свойств, но разными значениями
// ----------------------------------------------------------------------------------------
const books = [
  {
    title: "The Kingdom",
    author: "Cornwell",
    rating: 8.38,
  },
  {
    title: "На березі",
    author: "Шеклі",
    rating: 8.51,
  },
  {
    title: "Сон людини",
    author: "Достоєвський",
    rating: 7.75,
  },
];
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Переборка массива объектов через цикл for...of
// ========================================================================================
// Значения свойств каждого объекта - используя синтаксис «через точку»
// ----------------------------------------------------------------------------------------
for (const book of books) {
  // Объект книги
  console.log(book);
  // Название
  console.log(book.title);
  // Автор
  console.log(book.author);
  // Рейтинг
  console.log(book.rating);
}
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Пример. Получить названия всех книг из массива  books
// ========================================================================================
const bookNames=[]
for (const book of books) {
  bookNames.push(book.title);
}
console.log(bookNames)
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Пример. Посчитать средний рейтинг книг
// ========================================================================================
//
// ----------------------------------------------------------------------------------------
// Общий рейтинг
let totalRating = 0;
for (const book of books) {
  totalRating = totalRating + book.rating;
}
// Средний рейтинг = Общий рейтинн / количество книг
// и округляем до 2 знаков после запятой   .toFixed(2)
const averageRating = (totalRating / books.length).toFixed(2);

console.log('Количество книг в массиве -', books.length);
console.log('Общий рейтинг -', totalRating);
console.log('Средний рейтинг -', averageRating);
// ----------------------------------------------------------------------------------------


// ========================================================================================
// ...   spread: передача аргументів
// ========================================================================================
// Позволяет разделить коллекцию элементов (массив, строка или объект)
// в место, в котором ожидается набор отдельных значений.
// Создаются КОПИИ элементов.
// Оригинальная коллекция (массив и т.п.) НЕ ИЗМЕНЯЕТСЯ.
// ----------------------------------------------------------------------------------------
// Пример. метод Math.max(аргументы) ищет и возвращает наибольший
// из аргументов(чисел), то есть ожидает не массив, а количество аргументов.
// ----------------------------------------------------------------------------------------
const temps = [14, -4, 25, 8, 11];

// В консолу будет массив
console.log(temps);
// ❌ Так не сработает, так как передается целый массив
console.log(Math.max(temps)); // NaN

// А так в консоле будет отдельный набор чисел
console.log(...temps);  // 14 -4 25 8 11
// ✅ Распределяется массив и высчитывается максимальное число
console.log(Math.max(...temps)); // 25
// ----------------------------------------------------------------------------------------


// ========================================================================================
// ...  spread: создание нового массива
// ========================================================================================
// Операция ... (spread) позволяет создать КОПИЮ массива
// или «склеить» произвольное количество массивов в один новый.
// Раньше для этого использовали методы slice() і concat().
// ----------------------------------------------------------------------------------------

// Это точная, но независимая копия массива temps
const copyOfTemps = [...temps];
console.log('Новый массив - ',copyOfTemps); // [14, -4, 25, 8, 11]
// ----------------------------------------------------------------------------------------


// ========================================================================================
// ...  spread: объединение массивов в новый массив
// ========================================================================================
// Порядок важен - он влияет на порядок элементов в новом массиве.
// ----------------------------------------------------------------------------------------
const lastWeekTemps = [14, 25, 11];
const currentWeekTemps = [23, 17, 18];
// Объединение массивов в один новый
const allTemps = [...lastWeekTemps, ...currentWeekTemps];
console.log('Объединенный массив - ',allTemps); // [14, 25, 11, 23, 17, 18]
// ----------------------------------------------------------------------------------------

// ========================================================================================
// ...  spread: создание нового объекта​
// ========================================================================================
// Операция ... (spread) позволяет расспределить свойства произвольного
// количества объектов в один новый объект.
// ----------------------------------------------------------------------------------------
const first = { propA: 5, propB: 10 };
const second = { propC: 15 };
const third = { ...first, ...second };
console.log(third); // { propA: 5, propB: 10, propC: 15 }
// ----------------------------------------------------------------------------------------
// Порядок распределения имеет значение
// Имена свойств - уникальны, поэтому свойства нового объекта,
// могут быть перезаписаны значення уже существующего свойства,
// если их имена совпадают.
// ----------------------------------------------------------------------------------------
const first1 = { propA: 5, propB: 10, propC: 50 };
const second1 = { propC: 15, propD: 20 };

// second1.propC: 15  переписывает значение  first1.propC: 50
const third1 = { ...first1, ...second1 };
console.log(third1); // { propA: 5, propB: 10, propC: 15, propD: 20 }

// first1.propC: 50  переписывает значение  second1.propC: 15
const fourth1 = { ...second1, ...first1 };
console.log(fourth1); // { propA: 5, propB: 10, propC: 50, propD: 20 }

// При распределении можно добавлять свойство со значением в любое место
// Главное - помнить об уникальности имени свойства и возможности перезаписи.
const first2 = { propA: 5, propB: 10, propC: 50 };
const second2 = { propC: 15 };

const third2 = { propB: 20, ...first2, ...second2 };
console.log(third2); // { propA: 5, propB: 10, propC: 15 }

const fourth2 = { ...first2, ...second2, propB: 20 };
console.log(fourth2); // { propA: 5, propB: 20, propC: 15 }

const fifth2 = { ...first2, propB: 20, ...second2 };
console.log(fifth2); // { propA: 5, propB: 20, propC: 15 }
// ----------------------------------------------------------------------------------------

// ========================================================================================
// ...  rest: собирание всех аргументов функции
// ========================================================================================
// Операция ... (rest) позволяет собрать группу независимых элементов в новую коллекцию
// Имя параметра может быть произвольным
// Чаще всего его называют args, restArgs или otherArgs - сокр. от arguments.
// ----------------------------------------------------------------------------------------
function multiply(...args) {
  console.log(args); // массив всех аргументов
}
// Передача разного количества аргументов в функцию
multiply(1, 2);
multiply(1, 2, 3);
multiply(1, 2, 3, 4);
// ----------------------------------------------------------------------------------------

// ========================================================================================
// ...  rest: собирание части аргументов функции
// ========================================================================================
// Операция ... (rest) также позволяет собрать в массив только
// ту часть аргументов, которая необходима.
// ----------------------------------------------------------------------------------------
// Все аргументы, для которых будут объявлены параметры, передадут
// им свои значенияя, остальные аргументы будут помещены в массив. 
// Операция ... (rest) должна быть последней в списке параметров функции.
// ----------------------------------------------------------------------------------------
function multi(firstNumber, secondNumber, ...otherArgs) {
  console.log(firstNumber); // Значение первого аргумента
  console.log(secondNumber); // Значение второго аргумента
  console.log(otherArgs); // Массив остальных аргументов
}
// Вызов функции с разными аргументами
multi(1, 2);
multi(1, 2, 3);
multi(1, 2, 3, 4);
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Деструктурирование объектов
// ========================================================================================
// Сложные данные всегда представлены объектом
// Многократные обращения к свойствам объекта визуально усложняют код :
// ----------------------------------------------------------------------------------------
const film = {
  title: "The Last Kingdom",
  author: "Bernard Cornwell",
  genres: ["historical prose", "adventure"],
  isPublic: true,
  rating: 8.38,
};

const accessType = film.isPublic ? "публичном" : "закрытом";
const message = `Фильм ${film.title} автора ${film.author} с рейтингом ${film.rating} 
находится в ${accessType} доступе.`;
console.log(message);
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Деструктуризация позволяет распаковать значения свойств в локальные переменные.
// ========================================================================================
// Деструктуризация всегда находится в левой части операции присваивания. 
// Переменным внутри фигурных скобок присваиваются значения свойств объекта. 
// Если имя переменной и имя свойства -совпадают, происходит присвавание, 
// В другом случае, переменной будет присвоено значение - undefined. 
// Порядод объфвления переменных в фигурных скобках - неважен.
// ----------------------------------------------------------------------------------------

// Деструктуризация свойств в переменные, причем coverImage - нет в свойствах объекта
const { title, author, isPublic, rating, coverImage } = film;
console.log(title, author, isPublic, rating);
console.log(coverImage); // undefined

// ========================================================================================
// Значення по умолчанию при деструктуризации
// ========================================================================================
// Для того, чтобы избежать присвоения  undefined во время деструктуризации
// несуществующих свойств объекта, можна задать переменным значение по умолчанию,
// которые будут присвоены только тогда !!! , если нет свойства с таким именем.
// ----------------------------------------------------------------------------------------
// Добавляем изображение обложки, если этого свойства нет в объекте
const {
  coverImage1 = "https://via.placeholder.com/640/480",
} = film;

console.log(title); // The Last Kingdom
console.log(author); // Bernard Cornwell
console.log(coverImage1); // https://via.placeholder.com/640/480
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Изменение имени переменной при деструктуризации
// ========================================================================================
// Во время деструктуризации можно изменить имя переменной, в которую
// распаковываютя значения свойства
// Сначала пишется имя свойства, из которого мы хотим получить значение,
// После чего ставим двоеточие и пишем имя переменной, в которую
// необходимо поместить значение этого свойства.
// ----------------------------------------------------------------------------------------
const firstBook = {
  title: "The Last Kingdom",
  coverImage:
    "https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg",
};

// Значение в firstCoverImage НЕ меняется на значение по умолчанию 
// так как в объекте firstBook - ЕСТЬ свойство coverImage
const {
  title: firstTitle,
  coverImage: firstCoverImage = "https://via.placeholder.com/640/480",
} = firstBook;

console.log(firstTitle); // The Last Kingdom
console.log(firstCoverImage); // https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg
// ----------------------------------------------------------------------------------------

const secondBook = {
  title: "Сон смішної людини",
};

// Значение в secondCoverImage УСТАНАВЛИВАЕТСЯ значение по умолчанию 
// так как в объекте secondBook - НЕТ свойства coverImage
const {
  title: secondTitle,
  coverImage: secondCoverImage = "https://via.placeholder.com/640/480",
} = secondBook;

console.log(secondTitle); // Сон смішної людини
console.log(secondCoverImage); // https://via.placeholder.com/640/480
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Деструктуризация в циклах
// ========================================================================================
// Перебирая массив объектов циклом for...of, создаются многоразовые
// обращения к свойствам объекта.
// Можно деструктуризировать свойства объекта в локальные переменные в теле цикла
// ----------------------------------------------------------------------------------------
const journals = [
  {
    title: "The Last Kingdom",
    author: "Bernard Cornwell",
    rating: 8.38,
  },
  {
    title: "На березі спокійних вод",
    author: "Роберт Шеклі",
    rating: 8.51,
  },
];

// Вариант без деструктуризации
for (const journal of journals) {
  console.log(journal.title);
  console.log(journal.author);
  console.log(journal.rating);
}

// Вариант с деструктуризацией в локальные переменные цикла
for (const journal of journals) {
  const { title, author, rating } = journal;

  console.log(title);
  console.log(author);
  console.log(rating);
}
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Глубокая деструктуризация
// ========================================================================================
// При деструктуризации объектов в вложенными объектами
// ----------------------------------------------------------------------------------------
const userPro = {
  namePro: "Jacques Gluke",
  tag: "jgluke",
  stats: {
    followers: 5603,
    views: 4827,
    likes: 1308,
  },
};

// Деструктуризация в переменные
const {
  namePro,
  tag,
  stats: { followers, views: userViews, likes: userLikes = 0 },
} = userPro;

console.log(namePro); // Jacques Gluke
console.log(tag); // jgluke
console.log(followers); // 5603
console.log(userViews); // 4827
console.log(userLikes); // 1308
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Деструктуризация масивов
// ========================================================================================
// Деструктурированное присваивание можно использовать и для массивов :
// 1. Вместо фигурних скобок {} используются квадратные [].
// 2. Переменнным, указанным в квадратных скобках [], будут 
//    ПОСЛЕДОВАТЕЛЬНО присваиваться значения элементов массива.
// ----------------------------------------------------------------------------------------
const rgb = [200, 255, 100];
const [red, green, blue] = rgb;

console.log(`R:${red},G:${green},B:${blue}`); // "R:200,G:255,B:100"

// ----------------------------------------------------------------------------------------
// После ключевого слова  const или  let  ставим квадратные скобки,
// как и в случае объявления массива.
// Внутри скобок, через запятую, указываются имена переменных,
// в которые будут помещены значения элементов массива.
// Будут созданы переменные, и в них будут зазмещены элементы
// в номерованном порядке - от 0 і до конца массива.
// Во время деструктуризации массивов, значение переменной может 
// присваиваться после её объявления
// ----------------------------------------------------------------------------------------
const rgb1 = [200, 255, 100];
let red1, green1, blue1;

[red1, green1, blue1] = rgb1;

console.log(`R:${red1},G:${green1},B:${blue1}`); // "R:200,G:255,B:100"

// ----------------------------------------------------------------------------------------
// Если переменных больше, чем элементов массива, им будет присвоено  undefined, 
// поэтому можно уазывать значение  ПО УМОЛЧАНИЮ.
// ----------------------------------------------------------------------------------------
const rgb2 = [200, 100, 255];

const [red2, green2, blue2, alfa2 = 0.3] = rgb2;

console.log(`R:${red2},G:${green2},B:${blue2},Alfa:${alfa2}`); // "R:200,G:100,B:255,Alfa:0.3"

// ----------------------------------------------------------------------------------------
// Иногда из массива необходимо деструктурировать только первые  N элементов,
// а другие - сохранить в одну переменную в виде массива.
// Можно распаковать и присвоить другую часть элементов массива переменной,
// используя операцию   ... (rest).
// ----------------------------------------------------------------------------------------
const rgb3 = [200, 255, 100];

const [red3, ...colors3] = rgb3;

console.log(red3); // "200"
console.log(colors3); // [255, 100]

// ----------------------------------------------------------------------------------------
// Элементы можно пропускать 
// Например, из массива необходимо взять только последнее значение :
// ----------------------------------------------------------------------------------------
const rgb4 = [200, 255, 100];

const [, , blue4] = rgb4;

console.log(blue4); // "100"
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Паттерн «Объект параметров»
// ========================================================================================
// Меняет набор параметров - объектом с именованными свойствами
// ----------------------------------------------------------------------------------------

// Функция с параметром - объектом с определенными свойствами
function doStuffWithBook(book) {
  // Деструктуризация объекта
  const { title, numberOfPages, downloads, rating, isPublic } = book;
  console.log(title);
  console.log(numberOfPages);
}

// Вызов функции с аргументом - объектом с именованными свойствами
doStuffWithBook({
  title: "Название книги",
  numberOfPages: 736,
  downloads: 10283,
  rating: 8.38,
  isPublic: true,
});

// ----------------------------------------------------------------------------------------

