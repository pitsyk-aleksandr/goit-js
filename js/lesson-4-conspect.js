// Модуль 4
// Перебирающие методы массива.
// ****************************************************************************************

// Примеры из конспекта 

// ========================================================================================
// Колбек-функции (callback)
// ========================================================================================
// Функция не отличается от чисел, строк или массивов - это просто
// специальный тип данных (объект высшего порядка), - значение, которое
// можно сохранять в переменной или передавать в качестве аргумента
// в другую функцию.
// ----------------------------------------------------------------------------------------
// Определение функции
function greet(name) {
  return `Ласкаво просимо ${name}.`;
}

// Вызов функции и вывод РЕЗУЛЬТАТА в консоль
console.log(greet("Манго")); // Ласкаво просимо Манго.

// Выводим функцию greet в консоль, не вызывая её
console.log(greet); // ƒ greet() { return `Ласкаво просимо ${name}.`; }

// ----------------------------------------------------------------------------------------
// В первом случае, вызываем функцию   greet  с помощью круглых скобок,
// и в консоль выводится результат выполнения функции.
// Во втором случае передается ССЫЛКА на функцию, а не результат вызова
// (отсутствуют круглые скобки), поэтому в консоль выводится тело функции.
// ----------------------------------------------------------------------------------------
// Это значит,что функцию можно присвоить в переменную или
// передать как аргумент другой функции !!!
// ----------------------------------------------------------------------------------------

const fGreet = greet;
console.log('Функция - ', greet);

// ========================================================================================
// Функция обратного вызова (callback, колбек) - это функция, которая передается
// другой функции как аргумент, а та, в свою очередь, вызывает переданную функцию.
// ========================================================================================
// Функция высшего порядка (higher order function) - функция, которая принимает
// в качестве параметров другие функции или возвращает функцию в качестве результата.
// ========================================================================================

// Колбек-функция
function privet(name) {
  console.log(`Добро пожаловать - ${name}.`);
}

// Функция высшего порядка
function registerGuest(name, callback) {
    console.log(`Регистрируем гостя - ${name}.`); // Регистрируем гостя - Саша.
    // Вызов колбек-функции с аргументом - имя гостя
    callback(name); // Добро пожаловать - Саша.
}

// Вызов функции высшего порядка с аргументами : имя гостя и название колбек-функции
registerGuest("Саша", privet);
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Инлайн-колбек
// ========================================================================================
// Если функция маленькая, и нужна только для передачи аргументом, то её можно
// объявить непосредственно в момент вызова функции, в которую передаем колбек.
// Эта функция будет доступна только в качестве параметра и больше нигде.
// ----------------------------------------------------------------------------------------

// Объявление функции
function registerGuestNew(name, callback) {
  console.log(`Реєструємо гостя ${name}.`);
  callback(name);
}

// Вызываем функцию регистрации и передаём инлайн-функцию greet в качестве колбека
registerGuestNew("Манго", function greetNew(name) {
  console.log(`Ласкаво просимо ${name}.`);
});

// Вызываем функцию регистрации и передаём инлайн-функцию notify в качестве колбека
registerGuestNew("Полі", function notifyNew(name) {
  console.log(`Шановний(а) ${name}, ваш номер буде готовий за 30 хвилин.`);
});
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Несколько колбек-функций
// ========================================================================================
// Функция может принимать любое количество колбеков
// ----------------------------------------------------------------------------------------
// Пример : Варианты обработки звонка при доступности/недоступности абонента
// ----------------------------------------------------------------------------------------
function processCall(recipient, onAvailable, onNotAvailable) {
  // Имитируем доступность абонента случайным числом
  const isRecipientAvailable = Math.random() > 0.5;

  // Если абонент НЕ доступен
  if (!isRecipientAvailable) {
    onNotAvailable(recipient);
    return;
  }
  // Если абонент доступен
  onAvailable(recipient);
}

function takeCall(name) {
  console.log(`З'єднуємо з ${name}, очікуйте...`);
  // Логика принятия звонка
}

function activateAnsweringMachine(name) {
  console.log(`Абонент ${name} недоступний, залиште повідомлення.`);
  // Логика активации автоответчика
}

function leaveHoloMessage(name) {
  console.log(`Абонент ${name} недоступний, записуємо голограму.`);
  // Логика записи голограммы
}

// Вызов функции с обработкой звонка абонента и указанием :
//     - абонента
//     - функции-обработцика при доступности абонента
//     - функции-обработцика при НЕ доступности абонента
processCall("Манго", takeCall, activateAnsweringMachine);
processCall("Полі", takeCall, leaveHoloMessage);

// ----------------------------------------------------------------------------------------
// Колбеки применяются для обработки действий пользователя на страничкеБ
// на момент обработки запроса на сервер, выполнения заранее неизвестных
// функций. Это функции, предназначенные для отложенного использования.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Абстрактное повторение
// ========================================================================================
// Абстракция - спрятывание деталей реализации
// Функции - это хороший спосиб построения абстракций.
// ----------------------------------------------------------------------------------------
// Объявление функции - Печать значения
function printValue(value) {
  console.log(value);
}
// Объявление функции - Печать текста и значения
function prettyPrint(value) {
  console.log("Logging value: ", value);
}
// Объявление функции - Повторение определенного действия
function repeat(n, action) {
  for (let i = 0; i < n; i += 1) {
    action(i);
  }
}

// Передаём printValue как callback-функцию - с указанием ТИПА действия
repeat(3, printValue);
// 0
// 1
// 2

// Передаём prettyPrint как callback-функцию - с указанием ТИПА действия
repeat(2, prettyPrint);
// Logging value: 0
// Logging value: 1

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод forEach
// ========================================================================================
// Метод переборки массива, который используется для замены циклов
// for і for...of в работе с коллекцией данных.
// ----------------------------------------------------------------------------------------
//    массив.forEach(function callback(element, index, array) {
//        Тіло колбек-функції
//    });
// ----------------------------------------------------------------------------------------
// - Поэлементно перебирает массив
// - Вызывает колбек-функцию для каждого элемента массива.
// - Ничего не возвращает.
// Аргументы колбек-функции - это значения текущего элемента element,
// его индекс index и собственно - исходной массив array.
// Можно объявлять только необходиые параметры, чаще всего - это элемент,
// главное - не забывать о порядке параметров.
// ----------------------------------------------------------------------------------------
// Прервать выполнение метода forEach нельзя, всегда перебирается массив до конца.
// ----------------------------------------------------------------------------------------
const numbers = [5, 10, 15, 20, 25];

// Классический for
for (let i = 0; i < numbers.length; i += 1) {
  console.log(`Индекс ${i}, значение ${numbers[i]}`);
}

let arrayNew = [];
// Метод переборки forEach
numbers.forEach(function (number, index, array) {
    console.log(`Индекс ${index}, значение ${number}`);
    arrayNew.push(number); // Добавляем элемент в новый массива
    console.log('array - ', array); // текущий массив  numbers
    console.log('arrayNew - ',arrayNew); 
});

// ========================================================================================
// Стрелочные функции
// ========================================================================================
// Стрелочные функции имеют сокращенный синтаксис, который уменьшает размер кода,
// особенно когда функция маленькая или она используется в качестве колбек.
// Все стрелки создаются как функциональное вражение и её необходимо присваивать переменной.
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Обычное объявление функции сложения чисел
// ----------------------------------------------------------------------------------------
function classicAdd(a, b, c) {
  return a + b + c;
}

// ----------------------------------------------------------------------------------------
// Ключевое слово function не используется, вместо этого сразу объявляются параметры ,
// после этого символ  =>  и тело функции.
// Если параметров несколько, то они перечисляются через запятую в круглых скобках,
// между знаками равно  =  и стрелкой  =>.
// ----------------------------------------------------------------------------------------
// Функция сложения чисел - стрелочной функцией
// ----------------------------------------------------------------------------------------
const arrowAdd = (a, b, c) => {
  return a + b + c;
};
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Если параметр один, то его можно объявлять без круглых скобок.
// ----------------------------------------------------------------------------------------
const add = a => {
  return a + 5;
};
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Если параметры отсутствуют, то обязательно должны быть пустые круглые скобки.
// ----------------------------------------------------------------------------------------
const greetNew = () => {
  console.log("Привіт!");
};
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Явное возвращение стрелочной функции (explicit return)
// ========================================================================================
// В стрелочной функции после символа  =>  находится её телою.
// Есть 2 варианта: с фигурными скобками и без них.
// ----------------------------------------------------------------------------------------
// Если есть фигурные скобки, и функция должна возвращать значение, нужно явно поставить return. 
// Это называется явное возвращение (explicit return).    Такой синтаксис используется, 
// если в теле функции нужно выполнить еще какие-то инструкциия, кроме возврата значения.
// ----------------------------------------------------------------------------------------
const addExp = (a, b, c) => {
  console.log(a, b, c);
  return a + b + c;
};
// ----------------------------------------------------------------------------------------

// ========================================================================================
// НЕявное возвращение стрелочной функции (implicit return)
// ========================================================================================
// Если фигурных скобок нет, то возвращается результат выражения, которое стоит после  =>. 
// Это называется неявное возвращение (implicit return).  Такой синтаксис допустим
// только когда в теле функции не нужно выполнять других инструкций, кроме возврата значения.
// ----------------------------------------------------------------------------------------
const addImp = (a, b, c) => a + b + c;
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Псевдомасив arguments
// ========================================================================================
// У стрелочных функций нет локальной переменной  arguments, которая содержит все аргументы.
// Если необходимо собрать все аргументы в массив, используется операция ... rest.
// ----------------------------------------------------------------------------------------
const addRest = (...args) => {
  console.log(args); //    Получаем массив аргументов
};

add(1, 2, 3); // [1, 2, 3]
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Стрелочные функции как колбеки
// ========================================================================================
// Анонимные стрелочные функции отлично подходят как колбект для перебирающих методов массива
// благодаря короткому синтаксису объявления, особенно когде не нужно тело функции.
// ----------------------------------------------------------------------------------------
const numbers1 = [5, 10, 15, 20, 25];

// Обычное объявление анонимной функции - колбека
numbers1.forEach(function (number, index) {
  console.log(`Індекс ${index}, значення ${number}`);
});

// Анонимная стрелочная функция
numbers1.forEach((number, index) => {
  console.log(`Індекс ${index}, значення ${number}`);
});

// ----------------------------------------------------------------------------------------
// Стрелочную функцию также можно объявлять по имени отдельно и передавать на нее ссылку.
// Это делается, когда одна функция используется в нескольких местах программы или она большая.
// ----------------------------------------------------------------------------------------

const numbers2 = [5, 10, 15, 20, 25];

// Именованная стрелочная функция
const logMessage = (number, index) => {
  console.log(`Індекс ${index}, значення ${number}`);
};

// Вызов функции в методе массива
numbers2.forEach(logMessage);
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Чистые функции
// ========================================================================================

// ----------------------------------------------------------------------------------------
// Функция с побочными эффуктами - это функция, которая в процессе выпосления
// может изменять или использовать глобальные переменные, изменять значения аргументов
// ссылочного типа, использовать операции ввода-вывода и т.п.
// ----------------------------------------------------------------------------------------
// Пример - Функция увеличения каждого значения массива в 2 раза с изменением значений массива
const dirtyMultiply = (array, value) => {
  for (let i = 0; i < array.length; i += 1) {
    array[i] = array[i] * value;
  }
};
// Исходный массив
const numbers3 = [1, 2, 3, 4, 5];
dirtyMultiply(numbers3, 2);
// Произошло изменение исходных данных - массива  numbers
console.log('numbers3 - ',numbers3); // [2, 4, 6, 8, 10]

// ----------------------------------------------------------------------------------------
// Чистая функция (pure function) - это функция, результат которой зависит только от
// значений переданных аргументов. При условии одинаковых аргументов она всегда возвращает
// один и тот же результат и не имеет побочных эффектов, то есть не изменяет значения аргументов.
// ----------------------------------------------------------------------------------------
// Пример - Функция увеличения каждого значения массива в 2 раза с получением нового массива
const pureMultiply = (array, value) => {
  const newArray = [];

  array.forEach(element => {
    newArray.push(element * value);
  });

  return newArray;
};

const numbers4 = [1, 2, 3, 4, 5];
const doubledNumbers = pureMultiply(numbers4, 2);

// Изменение (мутация) исходных данных не произошла
console.log('numbers4 - ',numbers4); // [1, 2, 3, 4, 5]
// Функция вернула новый массив с измененными данными
console.log('doubledNumbers - ',doubledNumbers); // [2, 4, 6, 8, 10]
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Перебирающие методы массива
// ========================================================================================
// В JS есть методы массивов, которые пришли из функциональных языков.
// Большинство из них - чистые функции.
// Они создают новый массив, заполняют его, применяя к значению каждого элемента
// определенную колбек-функцию, после чего - возвращают этот новый массив.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :  array.method(callback[currentValue, index, array])
// ----------------------------------------------------------------------------------------
// Исходный массив  array, вызов метода  method  и  callback-функция  callback как аргумент метода.
// ----------------------------------------------------------------------------------------
// У большинства методов аргументами  callback-функции  являются :
// значение элемента  currentValue (первый параметр)
// позиция элемента  index  (второй параметр)
// и сам исходный массив  array (третий параметр).
// ----------------------------------------------------------------------------------------
//    array.method((item, idx, arr) => {
//        // логика, которая будет применена на каждой итерации
//    });
// ----------------------------------------------------------------------------------------
// Все параметры, кроме значения элемента item, - необязательные.
// Названия параметров могут быть любыми, но есть определенные договоренности
// ----------------------------------------------------------------------------------------
//    array.method(item => {
//       // логіка, яка буде застосовуватися на кожній ітерації
//    });
// ----------------------------------------------------------------------------------------



// ========================================================================================
// Метод map()
// ========================================================================================
// Метод map(callback) используется для трансформации массива.
// Метод вызывает колбек-функцию для каждого элемента исходного массива, а результат
// её работы записывает в новый массив, который и будет результатом выполнения метода.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
//    массив.map((element, index, array) => {
//       // Тело колбек-функции
//    });
// ----------------------------------------------------------------------------------------
// 1. Поэлементно перебирает оригинальный массив.
// 2. Не меняет оригинальный массив.
// 3. Регультат работы колбек функции записывается в новый массив.
// 4. Возвращает новый массив той же длины, что и оригинальный-исходный.
// ----------------------------------------------------------------------------------------
// Метод можно использовать для того, чтобы изменить каждый элемент массива.
// Оригинальный массив используется как эталон, на основе которого можно делать новую коллекцию.
// ----------------------------------------------------------------------------------------

// ПРИМЕР. Перебрать массив планет и создать новые массивы названий в верхнем и нижнем регистре

const planets = ["Земля", "Марс", "Венера", "Юпітер"];

const planetsInUpperCase = planets.map(planet => planet.toUpperCase());
console.log(planetsInUpperCase); // ['ЗЕМЛЯ', 'МАРС', 'ВЕНЕРА', 'ЮПІТЕР']

const planetsInLowerCase = planets.map(planet => planet.toLowerCase());
console.log(planetsInLowerCase); // ['земля', 'марс', 'венера', 'юпітер']

// Оригинальный массив не изменился
console.log(planets); // ['Земля', 'Марс', 'Венера', 'Юпітер']

// ----------------------------------------------------------------------------------------
// Используя метод map(), можно перебирать массив объектов, и в колбек-функции вернуть
// значение свойства каждого из них.
// ----------------------------------------------------------------------------------------

// ПРИМЕР. Есть массив работников, а нужно получить отдельный массив их имен.

const workers = [
  { name: "Манго", score: 83 },
  { name: "Полі", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Ківі", score: 94 },
  { name: "Х'юстон", score: 64 },
];

const namesWorker = workers.map(worker => worker.name);

console.log(namesWorker);   // ['Манго', 'Полі', 'Аякс', 'Ківі', 'Х'юстон']

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод flatMap()
// ========================================================================================
// Метод flatMap(callback) - аналогичный методу map(), но применяется в случаях,
// когда результат - это многомерный массив, который необходимо «разгладить».
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
//    массив.flatMap((element, index, array) => {
//       // Тело колбек-функции
//    });
// ----------------------------------------------------------------------------------------
// ОН вызывает колбек-функцию для для каждого элемента исходного массива, а результат её
// работы записывает в новый массив. Отличие от map() в том, что новый массив «разглаживается»
// на глубину одной вложенности. этот разглаженный массив является результатом работы flatMap().
// ----------------------------------------------------------------------------------------

// ПРИМЕР.
// У массиве  students  сохраняется список студентов со списком предметов, которые он изучает
// в свойстве  courses. Необходимо составить список предметов, которые изучают все студенты.

// Массив студентов
let students = [
  { name: "Манго", courses: ["математика", "фізика"] },
  { name: "Полі", courses: ["інформатика", "математика"] },
  { name: "Ківі", courses: ["фізика", "біологія"] },
];

// Получение массива всех курсов - массив из массивов по каждому ученику
console.log(students.map(student => student.courses));
// [['математика', 'фізика'], ['інформатика', 'математика'], ['фізика', 'біологія']]

// Разглаживаем массив - превращаем его в массив элементов одного уровня на глубину 1 уровня вложения
console.log(students.flatMap(student => student.courses));
// ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];

// ----------------------------------------------------------------------------------------


// ========================================================================================
// Метод filter()
// ========================================================================================
// Метод filter(callback) используется для одной операции - фильтрации массива, когда
// необходимо выбрать больше одного элемента из коллекции по определенному критерию.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
//     массив.filter((element, index, array) => {
//       // Тело колбек-функции
//     });
// ----------------------------------------------------------------------------------------
// 1. Не меняет оригинальный массив.
// 2. Поэлементно перебирает оригинальный массив.
// 3. Возвращает новый массив.
// 4. Добавляет в возвращаемый массив элементы, которые удовлетворяют условиям колбек-функции.
//      Если колбек вернул true, элемент добавляется в новый массив.
//      Если колбек вернул false, элемент НЕ добавляется в новый массив.
//      Если ни один из элементов не удовлетворяет условию, то возвращает пустой массив.
// ----------------------------------------------------------------------------------------

// ПРИМЕР. Выбрать в отдельные массивы положительные, отрицательные числа, и те, которые больше 1000

const values = [51, -3, 27, 21, -68, 42, -37];

const positiveValues = values.filter(value => value >= 0);
console.log('positiveValues - ',positiveValues); // [51, 27, 21, 42]

const negativeValues = values.filter(value => value < 0);
console.log('negativeValues - ',negativeValues); // [-3, -68, -37]

const bigValues = values.filter(value => value > 1000);
console.log('bigValues - ',bigValues); // []

// Оригинальный массив не изменился
console.log('Оригинальный массив values - ',values); // [51, -3, 27, 21, -68, 42, -37]

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод filter() - Фильтрация для создания массива уникальных элементов
// ========================================================================================
// Используя метод filter(), можно выполнить фильтрицию массива таким образом, чтобы в нем
// остались только уникальные элементы.
// Этот прием работает только с массивом примитивных значений - НЕ объектов.
// ----------------------------------------------------------------------------------------
const studentsNew = [
  { name: "Манго", courses: ["математика", "фізика"] },
  { name: "Полі", courses: ["інформатика", "математика"] },
  { name: "Ківі", courses: ["фізика", "біологія"] },
];
// ----------------------------------------------------------------------------------------
// В переменной allCourses сохраняется массив всех предметов, которые могут повторяться. 
const allCourses = studentsNew.flatMap(student => student.courses);
console.log('allCourses - ', allCourses);
// ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];
// ----------------------------------------------------------------------------------------
// Необходимо сделать новый массив в котором будут только уникальные предметы, без повторений.
const uniqueCourses = allCourses.filter(
  (course, index, array) => array.indexOf(course) === index
);
console.log('uniqueCourses - ', uniqueCourses);
// ['математика', 'фізика', 'інформатика', 'біологія']
// ----------------------------------------------------------------------------------------
// Используя array.indexOf(course), выполняем поиск ПЕРВОГО вхождения текущего элемента course
// и получаем его индекс в оригинальном массиве всех предметов.
// В параметре index сохраняется индекс ТЕКУЩЕГО элемента course, перебирая массив методом filter.
// Если результат indexOf() и значение index равны - это уникальный элемент, так как это
// значение встречается в массиве впервый, и на текущей итерации фильтр обрабатывает именно его.
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Метод filter() - Фильтрация массива объектов
// ========================================================================================
// Во время работы с массивом объектов выполняется фильтрация по ЗНАЧЕНИЮ определенного СВОЙСТВА.
// В результате, получается новый массив отфильтрованных объектов.
// ========================================================================================
// ПРИМЕР.
// Есть массив студентов с баллами за тест. НЕобходимо отфильтровать лучших (балл више 80),
// худших (балл ниже 50) и средних студентов (балл от 50 до 80).
// ----------------------------------------------------------------------------------------
const LOW_SCORE = 50;
const HIGH_SCORE = 80;
let studentsScore = [
  { name: "Манго", score: 83 },
  { name: "Полі", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Ківі", score: 94 },
  { name: "Х'юстон", score: 64 },
];
// ----------------------------------------------------------------------------------------
const best = studentsScore.filter(student => student.score >= HIGH_SCORE);
console.log(best); // Массив объектов студентов Манго і Ківі
// ----------------------------------------------------------------------------------------
const worst = studentsScore.filter(student => student.score < LOW_SCORE);
console.log(worst); // Массив объекта студента  Аякс
// ----------------------------------------------------------------------------------------
// В колбек-функции можно в вызове деструктурировать свойства объекта student.score в переменную score
const average = studentsScore.filter(
  ({ score }) => (score >= LOW_SCORE) && (score < HIGH_SCORE)
);
console.log(average); // Массив объектов студентов  Полі і Х'юстон
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Метод find()
// ========================================================================================
// Если метод filter(callback) используется для поиска ВСЕХ элементов, удовлетворяющих условию,
// то метод find(callback) позволяет найти и вернуть первый соответствующий элемент,
// после чего переборка массива останавливается.
// Поиск производится до ПЕРВОГО совпадения.
// ========================================================================================
// СИНТАКСИС :
//      массив.find((element, index, array) => {
//         // Тело колбек-функции
//      });
// ----------------------------------------------------------------------------------------
// ЧТО ДЕЛАЕТ :
// 1. НЕ изменяет оригинальный массив.
// 2. Поєлементно перебирает оригинальный массив.
// 3. Возвращает первый элемент, который соответствует условию - когда колбек возвращает  true/
// 4. Если ни один элемент не соответствует условию, то есть для всех элементов колбек вернул
//    false, то метод возвращает  undefined.
// ----------------------------------------------------------------------------------------
// ЗАДАЧИ :
// Метод find() используется для одного задания - поиска элемента по уникальному значению
// свойства. Например, поиск пользователя по почте, книги- по названию, автомобиля - по номеру.
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// ПРИМЕР. Поиск объекта по названию цвета

const colorPickerOptions = [
  { label: "red", color: "#F44336" },
  { label: "green", color: "#4CAF50" },
  { label: "blue", color: "#2196F3" },
  { label: "pink", color: "#E91E63" },
  { label: "indigo", color: "#3F51B5" },
];

const color1 = colorPickerOptions.find(option => option.label === "blue"); 
console.log('color1 - ', color1);     // { label: 'blue', color: '#2196F3' }

const color2 = colorPickerOptions.find(option => option.label === "pink"); 
console.log('color2 - ', color2);     // { label: 'pink', color: '#E91E63' }

const color3 = colorPickerOptions.find(option => option.label === "white"); 
console.log('color3 - ', color3);     // undefined

// ----------------------------------------------------------------------------------------


// ========================================================================================
// Метод findIndex()
// ========================================================================================
// Метод findIndex(callback) - это современная замена метода indexOf().
// Позволяет выполнять поиск при более сложный условиях,чем просто равенство.
// Используется как для поиска в массиве примитивов, так и в массиве объектов.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
//      массив.findIndex((element, index, array) => {
//        // Тело колбек-функции
//      });
// ----------------------------------------------------------------------------------------
// ЧТО ДЕЛАЕТ :
// 1. НЕ изменяет оригинальный массива.
// 2. Поэлементно перебирает оригинальный массив.
// 3. Возвращает индекс перкого элемента, который удовлетворяет условию поиска, то есть
//    когда колбек возвращает  true.
// 4. Если ни один элемент не соответствует условию, то есть для всех элементов колбек вернул
//    false, то метод возвращает  -1.
// ----------------------------------------------------------------------------------------

// ПРИМЕР. Поиск по названию цвета и возвращение индекса элемента.

// const colorPickerOptions = [
//   { label: "red", color: "#F44336" },
//   { label: "green", color: "#4CAF50" },
//   { label: "blue", color: "#2196F3" },
//   { label: "pink", color: "#E91E63" },
//   { label: "indigo", color: "#3F51B5" },
// ];

const colorIndex1 = colorPickerOptions.findIndex(option => option.label === "blue");
console.log('colorIndex1 - ', colorIndex1);     // 2
const colorIndex2 = colorPickerOptions.findIndex(option => option.label === "pink");
console.log('colorIndex2 - ', colorIndex2);     // 3
const colorIndex3 = colorPickerOptions.findIndex(option => option.label === "white");
console.log('colorIndex3 - ', colorIndex3);     // -1
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Метод every()
// ========================================================================================
// Проверяет, проходят ли ВСЕ элементы массива тест колбек-функции.
// Возвращает  true  или  false.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
//      массив.every((element, index, array) => {
//         // Тело колбек-функции
//      });
// ----------------------------------------------------------------------------------------
// ЧТО ДЕЛАЕТ :
// 1. НЕ изменяет оригинальный массива.
// 2. Поэлементно перебирает оригинальный массив.
// 3. Возвращает true, если ВСЕ элементы массива удовлетворяют условию.
// 4. Возвращает false, если хотя бы один элемент массива НЕ удовлетворяет условию.
// 5. Переборка массива останавливается, если колбек вернул  false.
// ----------------------------------------------------------------------------------------
// ПРИМЕРЫ.
// Все элементы больше или равны 0?        -      ДА
[1, 2, 3, 4, 5].every(value => value >= 0);     // true

// Все элементы больше или равны 0?         -      НЕТ
[1, 2, 3, -10, 4, 5].every(value => value >= 0); // false
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод some()
// ========================================================================================
// Проверяет, проходит ли ХОТЯ БЫ ОДИН элемент массива тест колбек-функции.
// Возвращает  true  или  false.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
//      массив.some((element, index, array) => {
//         // Тело колбек-функции
//      });
// ----------------------------------------------------------------------------------------
// ЧТО ДЕЛАЕТ :
// 1. НЕ изменяет оригинальный массива.
// 2. Поэлементно перебирает оригинальный массив.
// 3. Возвращает true, если ХОТЯ БЫ ОДИН элемент массива удовлетворяет условию.
// 4. Возвращает false, если НИ один элемент массива НЕ удовлетворяет условию.
// 5. Переборка массива останавливается, если колбек вернул  true.
// ----------------------------------------------------------------------------------------

// ПРИМЕРЫ :

// Есть ли хотя бы один элемент, который больше или равен нулю? - ДА
[1, 2, 3, 4, 5].some(value => value >= 0); // true

// Есть ли хотя бы один элемент, который больше или равен нулю? - ДА
[-7, -20, 3, -10, -14].some(value => value >= 0); // true

// Есть ли хотя бы один элемент, который меньше нуля?  - НЕТ
[1, 2, 3, 4, 5].some(value => value < 0); // false

// Есть ли хотя бы один элемент, который меньше нуля?  - ДА
[1, 2, 3, -10, 4, 5].some(value => value < 0); // true

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Методы  every()  и  some() - при переборке массива объектов
// ========================================================================================
// Во время работы с массивом объектов проверяется значение их определенного свойства.
// ----------------------------------------------------------------------------------------
// ПРИМЕР :
// Есть массив объектов фруктов. Нужно узнать, есть ли фрукты в нальчии и
// Есть в наличии хотябы один фрукт (количество больше нуля)
// ----------------------------------------------------------------------------------------
const fruits = [
  { name: "apples", amount: 100 },
  { name: "bananas", amount: 0 },
  { name: "grapes", amount: 50 },
];

// every вернёт true, только если количество каждого фрукта будет больше 0 штук
const allAvailable = fruits.every(fruit => fruit.amount > 0); // false

// some вернёт  true, если количество ХОТЯ БЫ ОДНОГО фрукта будет больше нуля штук
const anyAvailable = fruits.some(fruits => fruits.amount > 0); // true
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Метод reduce()
// ========================================================================================
// Метод reduce(callback, initialValue) используется для последовательной обработки
// каждого элемнта массива с сохранением промежуточного результата, как аккумулятор.
// Метод reduce() используется, когда нужно взять "много" и привести к "одному". 
// В обычных заданиях его применение сводится к работе с числами.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
//      массив.reduce((previousValue, element, index, array) => {
//         // Тело колбек-функции
//      }, initialValue);
// ----------------------------------------------------------------------------------------
// ЧТО ДЕЛАЕТ :
// 1. НЕ изменяет оригинальный массива.
// 2. Поэлементно перебирает оригинальный массив.
// 3. Делает всё, что угодно.
// 4. Возвращает всё, что угодно.
// ----------------------------------------------------------------------------------------
// ПРИМЕР. Посчитать сумму элементов массива
// ----------------------------------------------------------------------------------------
// Первый параметр колбек-функції (previousValue) - это аккумулятор, то есть промежуточный результат.
// Значение, которое вернет колбек-функция на текущей итерации, будет значением этого параметра на следующей итерации.
// Вторым аргументом для reduce() можно передать необязательное начальное значение аккумулятора - параметр initialValue.
// ----------------------------------------------------------------------------------------
const total = [2, 7, 3, 14, 6].reduce((previousValue, number) => {
  return previousValue + number;
}, 0);

console.log('сумма элементов массива reduce() - ',total);     // 32
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод reduce() - при работе с массивом объектов
// ========================================================================================
// В массивах объектов используется для работы с числовыми значениями определенного свойства.
// ----------------------------------------------------------------------------------------
// ПРИМЕР. Посчитать среднее арифметическое от баллов успеваемости.

studentsScore = [
  { name: "Манго", score: 83 },
  { name: "Полі", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Ківі", score: 94 },
  { name: "Х'юстон", score: 64 },
];

// Название переменной - аккумулятора может быть произвольной, это просто параметр функции
const totalScore = studentsScore.reduce((total, student) => {
  return total + student.score;
}, 0);

const averageScore = totalScore / studentsScore.length;
console.log('totalScore - ', totalScore);
console.log('averageScore - ', averageScore);
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод reduce​() - расширеные возможности
// ========================================================================================
// ПРИМЕР :
// Из массива постов твиттера отдельного пользователя необходимо посчитать сумму всех лайков.
// ----------------------------------------------------------------------------------------
const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

// Пройдем по всем элементам коллекции и прибавим значение свойства likes
// к аккумулятору, начальное значение которого укажем = 0.
const likes = tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);

console.log('Количество всех лайков - ',likes); // 32

// Напишем функцию для подсчета лайков в коллекции
const countLikes = tweets => {
  return tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);
};

console.log('Количество всех лайков (функция) - ',countLikes(tweets)); // 32

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод sort()
// ========================================================================================
// Метод sort() сортирует элементы массива, но в отличие от других методов -
// метод сортирует исходный массив - вносит в него изменения.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
//      массив.sort();
// ----------------------------------------------------------------------------------------
// ЧТО ДЕЛАЕТ :
// 1. Сортирует и изменяет исходный массив.
// 2. Возвращает измененный массив - то есть ссылку на отсортированный исходный массив.
// 3. По умолчаний сортирует по возрастанию.
// 4. Сортировка производится путём приведения значения в строку и сравнение порядковых
//    номеров символов в таблице  Unicode.
// ----------------------------------------------------------------------------------------

// ПРИМЕР 1. Сортировка массива чисел по возрвстанию.

let scores = [61, 19, 74, 35, 92, 56];
scores.sort();
console.log('Отсортированный массив ', scores);  // [19, 35, 56, 61, 74, 92]

// ----------------------------------------------------------------------------------------

// ПРИМЕР 2.
// По умолчанию значения приводятся к строке и стандартная сортировка чисел работает необычно
// Массив из однозначных и двузначный чисел сортируется странно :

scores = [27, 2, 41, 4, 7, 3, 75];
scores.sort();
console.log('Странно отсортированный массив - ', scores); // [2, 27, 3, 4, 41, 7, 75]

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод sort ()  - сортировка строк
// ========================================================================================
// ----------------------------------------------------------------------------------------
// Массив строк сортируются по алфавиту
// ----------------------------------------------------------------------------------------
let mens = ["Вика", "Андрей", "Олег", "Юля", "Борис", "Катя"];
mens.sort();
console.log(mens);  // [ 'Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юля' ]

// ----------------------------------------------------------------------------------------
// Порядковый номер больших букв больше, чем у маленьких ( в таблице Unicode )
// ----------------------------------------------------------------------------------------
let letters = ["b", "B", "a", "A", "c", "C"];
letters.sort();
console.log(letters);   // ['A', 'B', 'C', 'a', 'b', 'c']

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод sort ()  - сортировка копии массива
// ========================================================================================
// Из-за того, что сортируется исходный массив, нарушается принцип чистоты функции.
// Невозможно сделать несколко коллекций с разным видом сортировки.
// Поэтому перед сортировкой обычно делают полную копию исходного массива и сортируют копию.
// ----------------------------------------------------------------------------------------

scores = [61, 19, 74, 35, 92, 56];
let ascendingScores = [...scores].sort();

console.log('Исходный массив - ',scores); // [61, 19, 74, 35, 92, 56]
console.log('Отсортированный массив - ',ascendingScores); // [19, 35, 56, 61, 74, 92]
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Свой порядок сортировки чисел
// ========================================================================================
// Для установки своего порядка сортировки методу sort(compareFunction) необходимо передать
// колбек-функцию с двумя параметрами - функцию сравнения.
// Это функция сравнения (compare function), порядок сорттровки зависит от её результата.
// Метод sort() будет вызывать её для двух произвольеых элементов.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
//      массив.sort((a, b) => {
//          // Тело колбек-функции
//      });
// ----------------------------------------------------------------------------------------
//    a - первый элемент для сравнения.
//    b - второй элемент для сравнения.
// ----------------------------------------------------------------------------------------
// Если вызов compareFunction(a, b) возвращает какое-то отризательное значение,
// то есть  a меньше  b, сортировка поставит  a  перед  b. 
// Это сортировка ПО ВОЗРАСТАНИЮ.
// ----------------------------------------------------------------------------------------

scores = [61, 19, 74, 35, 92, 56];
ascendingScores = [...scores].sort((a, b) => a - b);
console.log('Отсортированный массив - ', ascendingScores); // [19, 35, 56, 61, 74, 92],

// ----------------------------------------------------------------------------------------

scores = [21, 19, 2, 3, 33, 4, 45, 5, 105];
ascendingScores = [...scores].sort((a, b) => a - b);
// В этом случае абсолютно правильная сортировка чисел по возрастанию
console.log('Массив по возрастанию - ', ascendingScores); // [2, 3, 4, 5, 19, 21, 33, 45, 105]

// ----------------------------------------------------------------------------------------
// Если вызов compareFunction(a, b) возвращает какое-то положительное значение (больше 0),
// то есть  b  больше  a, то сортировка поставит  b  перед  a.
// Это сортировка ПО УБЫВАНИЮ.
// ----------------------------------------------------------------------------------------
scores = [21, 19, 2, 3, 33, 4, 45, 5, 105];
let descendingScores = [...scores].sort((a, b) => b - a);
// В этом случае абсолютно правильная сортировка чисел по убыванию
console.log('Массив по убыванию - ', descendingScores); // [105, 45, 33, 21, 19, 5, 4, 3, 2]
// ----------------------------------------------------------------------------------------
// Если вызов compareFunction(a, b) вернет 0, сортировка оставит  a  и  b  неизменными
// по отношению друг к другу, но отсортирует их по отношению ко всем другим элементам. 
// ----------------------------------------------------------------------------------------
scores = [21, 19, 2, 3, 44, 4, 3, 5, 99, 19];
ascendingScores = [...scores].sort((a, b) => a - b);
descendingScores = [...scores].sort((a, b) => b - a);
// В этом случае числа равные по значению стоят рядом
console.log('Массив по возрастанию - ', ascendingScores); // [2, 3, 3, 4, 5, 19, 19, 21, 44, 99]
console.log('Массив по убыванию - ', descendingScores);   // [99, 44, 21, 19, 19, 5, 4, 3, 3, 2]
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Свой порядок сортировки строк
// ========================================================================================
// Для сортировки строк в алфавитном порядке, по возрастанию или по убыванию,
// используется метод строк  localeCompare().
// ----------------------------------------------------------------------------------------
//     firstString.localeCompare(secondString)
// ----------------------------------------------------------------------------------------
// Он вызывается на строке, который необходимо сравнить  (firstString)
// с тем, который был передан этому методу как  аргумент (secondString).
// ----------------------------------------------------------------------------------------
// Возвращает отрицательное значение (меньше ноля), если firstString должен быть перед secondString.
// Возвращает положительное значение (больше ноля), если firstString должен быть после secondString.
// Если строки одинаковые, возвращается ноль.
// ----------------------------------------------------------------------------------------
"a".localeCompare("b"); // -1
"b".localeCompare("a"); // 1
"a".localeCompare("a"); // 0
"b".localeCompare("b"); // 0
// ----------------------------------------------------------------------------------------
// Это удобно использовать для сортрировки строк, так как метод sort() ожидает именно
// такие значения от колбек-функции.
// ----------------------------------------------------------------------------------------
mens = ["Вика", "Андрей", "Олег", "Юля", "Юлия", "Борис", "Катя"];

// Сортировка по алфавиту - как обычно
const inAlphabetOrder = [...mens].sort((a, b) => a.localeCompare(b));
console.log(inAlphabetOrder); // ['Андрей', 'Борис', 'Вика', 'Катя', 'Олег', 'Юлия', 'Юля']

// Сортировка по алфавиту - в обратном порядке
const inReversedOrder = [...mens].sort((a, b) => b.localeCompare(a));
console.log(inReversedOrder); // ['Юля', 'Юлия', 'Олег', 'Катя', 'Вика', 'Борис', 'Андрей']

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Сортировка объектов
// ========================================================================================
// Во время работы с массивом объектов, сортировка выполняется по числовому или строковому
// значению определенного свойства.
// ----------------------------------------------------------------------------------------
// ПРИМЕР.
// Нужно отсортировать массив объектов по увеличению/убыванию количества баллов и по имени студента.

students = [
  { name: "Манго", score: 83 },
  { name: "Полі", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Ківі", score: 94 },
];

// Сортировка по увеличению баллов
const inAscendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => firstStudent.score - secondStudent.score
);
console.log('Сортировка по увеличению баллов');
console.table(inAscendingScoreOrder);

// Сортировка по уменьшению баллов
const inDescendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => secondStudent.score - firstStudent.score
);
console.log('Сортировка по уменьшению баллов');
console.table(inDescendingScoreOrder);

// Сортировка по имени по алфавиту
const inAlphabeticalOrder = students.sort((firstStudent, secondStudent) =>
  firstStudent.name.localeCompare(secondStudent.name)
);
console.log('Сортировка по имени по алфавиту');
console.table(inAlphabeticalOrder);

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Цепочки методов
// ========================================================================================
// ----------------------------------------------------------------------------------------
// ПРИМЕР 1.
// Есть массив объектов с именами, баллами и предметами каждого студента.
// Необходимо получить массив их имён, отсортированных по увеличению баллов за тест.
// С этой целью мы отсортируем копию массива методом  sort(),  после чего методом  map()
// создадим массив значений свойства  name из отсортированного массива.
// ----------------------------------------------------------------------------------------

students = [
  { name: "Манго", score: 83, courses: ["математика", "фізика"] },
  { name: "Поли", score: 59, courses: ["інформатика", "математика"] },
  { name: "Аякс", score: 37, courses: ["фізика", "біологія"] },
  { name: "Киви", score: 94, courses: ["література", "інформатика"] },
];

const sortedByAscendingScore = [...students].sort((a, b) => a.score - b.score);
console.log('sortedByAscendingScore - ', sortedByAscendingScore); 

let names = sortedByAscendingScore.map(student => student.name);

console.log('names - ', names); // ['Аякс', 'Поли', 'Манго', 'Киви']

// ----------------------------------------------------------------------------------------
// Переменная  sortedByAscendingScore - лишняя и нужна только для промежуточного результата.
// Убрать лишние переменные можно с помощью вызова методов в цепочке.
// Каждый следующий метод будет выполняться на основе разультата работы предыдущего :
// ----------------------------------------------------------------------------------------
// 1. Делаем копию исходного массива перед сортировкой.
// 2. НА копии массива вызываем метод  sort().
// 3. На рузультат работы метода  sort()  применяем метод  map().
// 4. Переменной  names  присваиваем результат работы метода  map().
// ----------------------------------------------------------------------------------------
names = [...students]
  .sort((a, b) => a.score - b.score)
  .map(student => student.name);

console.log('names - ', names); // ['Аякс', 'Поли', 'Манго', 'Киви']
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// ПРИМЕР 2.
// Получить массив уникальных предметов, отсортированный по алфавиту.
// ----------------------------------------------------------------------------------------
// 1. На исходном массиве вызываем метод flatMap() и делаем разглаженный массив всех предметов.
// 2. На результат работы метода flatMap() применяем метод filter() для фильтрации уникальных элементов.
// 3. На результат метода  filter() вызываем sort().
// 4. Переменной  uniqueSortedCourses  присваиваем результат работы метода  sort().
// ----------------------------------------------------------------------------------------

const uniqueSortedCourses = students
  .flatMap(student => student.courses)
  .filter((course, index, array) => array.indexOf(course) === index)
  .sort((a, b) => a.localeCompare(b));

console.log(uniqueSortedCourses); // ['біологія', 'інформатика', 'література', 'математика', 'фізика']
// ----------------------------------------------------------------------------------------




