// Модуль 6
// DOM и события.
// ****************************************************************************************

// Примеры из конспекта

// ========================================================================================
// Объектная модель документа
// ========================================================================================
// При работе с браузером доступный функционал состоит из нескольких модулей,
// поскольку JavaScript не имеет инструментов для работы с браузером.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// DOM = Объектная модель документа (Document Object Model)
// ========================================================================================
// DOM – независимый от языка интерфейс для работы с HTML-документом.
// Содержит набор свойств и методов, позволяющих искать, создавать и удалять элементы,
// реагировать на действия пользователя и многое другое.
// То есть, соединяет страницу с языком программирования.
// ----------------------------------------------------------------------------------------
// DOM – это отображение HTML-документа, древовидная структура, в которой каждый узел –
// это JavaScript-объект со свойствами и методами, составляющий часть HTML-документа.
// Каждый элемент в документе, весь документ в целом, заголовок, ссылка, абзац – это части
// DOM этого документа, поэтому все они могут быть изменены с JavaScript-кода.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Объектная модель браузера (Browser Object Model)
// ========================================================================================
// BOM – независимый от языка интерфейс для работы с вкладкой браузера.
// Содержит набор свойств и методов, позволяющих получить доступ непосредственно
// к текущей вкладке и ряду функций браузера.
// Содержит объект работы с историей навигации, местоположением и многое другое.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// HTML-документ и DOM
// ========================================================================================
// Согласно DOM-модели каждый тег образует отдельный элемент-узел, каждый фрагмент текста -
// текстовый элемент.
// HTML-документ – это иерархическое дерево, в котором у каждого элемента (кроме корневого)
// есть только один родительский элемент, то есть элемент, внутри которого он располагается.
// Это дерево появляется за счет вложенной структуры тегов и текстовых частей.
// ----------------------------------------------------------------------------------------
// Чтобы отобразить HTML-документ, браузер сначала превращает его в понимаемый формат - DOM.
// Движок браузера имеет специальный фрагмент кода – HTML-парсер,
// который используется для преобразования HTML в DOM.
// ----------------------------------------------------------------------------------------
// В HTML вложенность определяет отношения  родитель-ребенок  между элементами.
// В DOM объекты соединены в древовидной структуре данных, фиксируя эти отношения.
// ----------------------------------------------------------------------------------------
// Браузер строит DOM постепенно, как только поступают первые фрагменты кода,
// он начинает парсить HTML, добавляя узлы в древовидную структуру.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Дерево HTML-документа
// ========================================================================================
// В этом дереве выделены два типа узлов.
// Узлы-элементы (element node) – образуются тегами, обычным образом одни элементы вложены
// в другие. Структура дерева образована только за счет них.
// ----------------------------------------------------------------------------------------
// Текстовые узлы (text node) – образуются текстом внутри элементов. Текстовый узел содержит
// только строчку текста и не может иметь дочерних элементов, то есть он всегда на самом
// низком уровне иерархии. Пробелы и перенос строк – это тоже текстовые узлы.
// ----------------------------------------------------------------------------------------
// Из этого правила есть исключения:
// - пробелы к head игнорируются,
// - любое содержимое после body не создает элемент, браузер переносит его в конец 'body'.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Навигация по DOM
// ========================================================================================
// DOM предоставляет широкий спектр возможностей для работы с элементом и его содержимым,
// но для этого сначала нужно получить ссылку на него.
// ----------------------------------------------------------------------------------------
// Доступ к DOM начинается с объекта document, из него можно добраться до любых элементов.
// ----------------------------------------------------------------------------------------
// document – ​​это часть глобального объекта window, который доступен в скрипте, когда он
// выполняется в браузере. Так же как alert, console.log, prompt и многие другие.
// ----------------------------------------------------------------------------------------
// Элементы DOM-дерева имеют иерархическое отношение друг к другу.
// Для описания отношений используются термины предок (ancestor), отпрыск (descendant),
// отец (parent), ребенок (child) и сосед (sibling).
// ----------------------------------------------------------------------------------------
// Самый высокий элемент называется корневым (root node).
// Каждый элемент, кроме корневого, имеет только один родительский элемент.
// У элемента может быть сколько угодно детей.
// Соседи – это элементы с общим родительским элементом.
// Дочерние элементы (дети) – элементы, которые находятся непосредственно внутри текущего (первая вложенность).
// Потомки - все элементы, которые находятся в текущем вместе с их детьми, детьми их детей и т.д.
// То есть все вроде дерева.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Свойства элемента для навигации по дереву
// ========================================================================================
// Для навигации по этой иерархии элементы обладают следующими свойствами.
// ----------------------------------------------------------------------------------------
// elem.parentNode – выберет родительский elem.
// elem.childNodes – псевдомассив, сохраняющий все дочерние элементы, включая текстовые.
// elem.children – псевдомассив, хранящий только дочерние узлы-элементы, то есть соответствующие тегам.
// elem.firstChild – выберет первый дочерний элемент внутри elem, включая текстовые узлы.
// elem.firstElementChild – выберет первый дочерний узел-элемент внутри elem.
// elem.lastChild – выберет последний дочерний элемент внутри elem, включая текстовые узлы.
// elem.lastElementChild – выберет последний дочерний узел-элемент внутри elem.
// elem.previousSibling – выберет элемент «слева» от elem (его предыдущего соседа).
// elem.previousElementSibling – выберет узел-элемент «слева» от elem (его предыдущего соседа).
// elem.nextSibling – выберет элемент «справа» от elem (его следующего соседа)
// elem.nextElementSibling – выберет узел-элемент «справа» от elem (его следующего соседа).
// ----------------------------------------------------------------------------------------
// DOM-коллекции, такие как childNodes и children - псевдомассивы (NodeList),
// у них нет большинства методов массива.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Поиск элементов
// ========================================================================================
// DOM-элемент – это объект со свойствами и методами.
// Самое время научиться быстро находить элемент по произвольному CSS-селектору.
// Группа методов element.querySelector* – это современный стандарт для поиска элементов.
// Они позволяют найти элемент или группу элементов по CSS-селектору любой сложности.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// element.querySelector(selector);
// ========================================================================================
// Используется, если нужно отыскать только один, часто уникальный элемент.
// Возвращает первый найденный элемент внутри element, соответствующий CSS-селектору selector.
// Если ничего не найдено, вернет null.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// element.querySelectorAll(selector);
// ========================================================================================
// Используется, если нужно найти коллекцию элементов, то есть получить массив ссылок
// на элементы с одинаковым селектором.
// К примеру, все элементы списка с классом menu-item.
// Возвращает псевдомассив всех элементов внутри element, соответствующих CSS-селектору selector.
// Если ничего не найдено, вернет пустой массив.
// ----------------------------------------------------------------------------------------

// Пример с изменением элементов списка на странице
// ----------------------------------------------------------------------------------------
// Поиск селектора по id - id="menu"
// ----------------------------------------------------------------------------------------
const listWithId = document.querySelector('#menu');

// Установка в атрибут style селектора - новых свойств 
listWithId.style.textTransform = 'uppercase'; 
listWithId.style.fontSize = '24px';

console.log(listWithId);

// ----------------------------------------------------------------------------------------
// Поиск селектора по классу - class="menu"
// ----------------------------------------------------------------------------------------
const listWithClass = document.querySelector('.menu');
console.log(listWithClass);

// ----------------------------------------------------------------------------------------
// Поиск всех селекторов по тегу - <li>
// ----------------------------------------------------------------------------------------
const menuItemsByTagName = document.querySelectorAll("li");

// Перебор массива селекторов с помощью метода forEach
// и установка для каждого элемента - селектора - нового свойства
menuItemsByTagName.forEach(element => element.style.color = 'blue');

console.log(menuItemsByTagName);

// ----------------------------------------------------------------------------------------
// Поиск всех селекторов по классу - class="menu-item"
// ----------------------------------------------------------------------------------------
const menuItemsByClass = document.querySelectorAll(".menu-item");
console.log(menuItemsByClass);

// ----------------------------------------------------------------------------------------
// Поиск одного(ПЕРВОГО) селекторов по классу - class="menu-item"
// ----------------------------------------------------------------------------------------
const firstMenuItem = document.querySelector(".menu-item");

// Установка в атрибут style селектора - нового свойства 
firstMenuItem.style.color = 'tomato';
console.log(firstMenuItem);

// ----------------------------------------------------------------------------------------


// ========================================================================================
// Свойства и атрибуты
// ========================================================================================
// При построении DOM-дерева некоторые стандартные HTML-атрибуты становятся свойствами элементов.
// ----------------------------------------------------------------------------------------
// Посмотрим на несколько часто используемых свойств :
//      value – содержит текущий текстовый контент элементов форм.
//      checked – сохраняет состояние чекбокса или радиокнопки.
//      name – сохраняет значение, указанное в HTML-атрибуте name.
//      src – путь к изображению тега <img>.
// ----------------------------------------------------------------------------------------

// Поиск селектора и присваивание переменной - ссылки на него 
const image = document.querySelector(".image");

// Получение значения свойств
console.log(image.src); // https://picsum.photos/id/9/320/240
console.log(image.alt); // A laptop

// Изменение значения свойств
image.src = "https://picsum.photos/id/13/640/480";
image.alt = "River bank";

console.log(image.src); // https://picsum.photos/id/13/640/480
console.log(image.alt); // River bank

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Свойство     textContent
// ========================================================================================
// elem.textContent возвращает текстовый контент внутри элемента.
// Доступный для чтения и записи.
// Неважно, что будет передано в textContent, данные всегда будут записаны как текст.
// ----------------------------------------------------------------------------------------

// Поиск селектора по классу "article-text"
const textEl = document.querySelector(".article-text");
// Получение значения свойства элемента textContent
console.log(textEl.textContent); // Гавайи - прекрасны

// Поиск селектора по классу "article-title"
const titleEl = document.querySelector(".article-title");
// Изменение значения свойства textContent - текстового контента
titleEl.textContent = 'Welcome to Bahamas!';

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Свойство      classList
// ========================================================================================
// В свойстве  classList  сохраняется объект с способами для работы с классами элемента.
// ----------------------------------------------------------------------------------------
// elem.classList.contains(cls) – возвращает true или false, в зависимости от наличия класса cls у элемента.
// elem.classList.add(cls) – добавляет класс cls в список классов элемента.
// elem.classList.remove(cls) – удаляет класс cls из списка классов элемента.
// elem.classList.toggle(cls) – если отсутствует класс cls, то добавляет его, если – присутствует, наоборот – удаляет.
// elem.classList.replace(oldClass, newClass) – заменяет существующий класс oldClass на указанный newClass.
// ----------------------------------------------------------------------------------------

const link = document.querySelector(".link");
console.log(link.classList); // ['link', 'is-active', value: 'link is-active']

// Проверка наличия класса
const hasActiveClass = link.classList.contains("is-active");
console.log(`hasActiveClass - ${hasActiveClass}`);  // hasActiveClass - true

// Добавление класса
link.classList.add("special");
console.log(link.classList); // ['link', 'is-active', 'special', value: 'link is-active special']

// Удаление класса
link.classList.remove("is-active");
console.log(link.classList); // ['link', 'special', value: 'link special']

// Добавление класса при отсутствии - удаление класса при наличии
link.classList.toggle("is-active");
console.log(link.classList); // ['link', 'special', 'is-active', value: 'link special is-active']

// Замена существующего класса
link.classList.replace("special", "regular");
console.log(link.classList); // ['link', 'regular', 'is-active', value: 'link regular is-active']

// ----------------------------------------------------------------------------------------


// ========================================================================================
// Свойство     style
// ========================================================================================
// Используется для чтения и смены инлайновых стилей.
// Возвращает объект CSSStyleDeclaration - inline styles object, содержащий список 
// всех свойств, определенных только во встроенных стилях элемента, а не весь CSS.
// ----------------------------------------------------------------------------------------
// При записи свойства записываются в camelCase,
// то есть  background-color  преобразуется в  element.style.backgroundColor  и т.д.
// ----------------------------------------------------------------------------------------
// На практике стилизация частей выполняется методом добавления CSS-классов.
// Свойство style используется для добавления любых динамических стилей, например во время анимации.
// ----------------------------------------------------------------------------------------

const button = document.querySelector(".btn");

button.style.backgroundColor = "teal";
button.style.fontSize = "24px";
button.style.textAlign = "center";

console.log(button.style); // CSSStyleDeclaration {0: 'background-color', 1: 'font-size',
// 2: 'text-align', accentColor: '', additiveSymbols: '', alignContent: '', alignItems: '', alignSelf: '', …}
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Атрибуты
// ========================================================================================
// DOM-элементам соответствуют HTML-теги, содержащие текстовые атрибуты.
// Доступ к атрибутам осуществляется с помощью стандартных методов.
// Эти методы работают со значением, находящимся в HTML.
// ----------------------------------------------------------------------------------------
//     elem.hasAttribute(name) – проверяет наличие атрибута, возвращает true или false.
//     elem.getAttribute(name) – получает значение атрибута и возвращает его.
//     elem.setAttribute(name, value) – устанавливает атрибут.
//     elem.removeAttribute(name) – удаляет атрибут.
//     elem.attributes – свойство, возвращающее объект всех атрибутов элемента.
// ----------------------------------------------------------------------------------------
const image2 = document.querySelector(".image-2");

console.log(image2.attributes); // NamedNodeMap {0: class, 1: src, 2: alt, length: 3}

// Проверка наличия атрибута
console.log(image2.hasAttribute("src")); // true

// Получение значения атрибута
console.log(image2.getAttribute("alt")); // "Rocks and waterfall"

// Установка значения атрибута
image2.setAttribute("alt", "Amazing nature");

// Получение значения атрибута
console.log(image2.getAttribute("alt")); // Amazing nature

// ----------------------------------------------------------------------------------------

// ========================================================================================
// data-атрибуты
// ========================================================================================
// Позволяют добавить в тег произвольный атрибут и получить его значение в JavaScript.
// ----------------------------------------------------------------------------------------
// Эта возможность используется для того, чтобы упростить написание кода, например,
// связать данные и разметку по уникальному идентификатору, указать тип действия кнопки и т.д.
// ----------------------------------------------------------------------------------------
// Для получения значения data-атрибута используется свойство  dataset,
// после которого следует имя атрибута.
// То есть data- отвергается, а другая часть имени записывается как имя свойства объекта.
// ----------------------------------------------------------------------------------------

// Поиск селектора - тег button, у которого есть атрибут data-action со значением "save"
const saveBtn = document.querySelector('button[data-action="save"]');
// Получение значения атрибута  data-action
console.log(saveBtn.dataset.action); // "save"

const closeBtn = document.querySelector('button[data-action="close"]');
console.log(closeBtn.dataset.action); // "close"

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Создание и удаление элементов
// ========================================================================================
// DOM API позволяет не только выбирать или изменять существующие, но и удалять,
// а также создавать новые элементы, после чего добавлять их в документ.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Создание элементов
// ========================================================================================
// document.createElement(tagName);
// ----------------------------------------------------------------------------------------
// Создает элемент с именем tagName и возвращает ссылку на него как результат своего исполнения.
// tagName - это строка, указывающая тип создаваемого элемента.
// Элемент создается в памяти, у DOM его еще нет.
// ----------------------------------------------------------------------------------------

// Создание элемента <h3></h3>
const heading = document.createElement("h3");
console.log(heading);   // <h3></h3>
// Изменение значения свойства элемента
heading.textContent = "This is a heading";
console.log(heading);   // <h3>This is a heading</h3>

// Создание элемента <img/>
const image3 = document.createElement("img");
image3.src = "https://picsum.photos/id/13/640/480";
image3.alt = "Nature";
console.log(image3);    // <img src="https://picsum.photos/id/13/640/480" alt="Nature" />

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Добавление элемента на страницу
// ========================================================================================
// Чтобы созданный элемент отображался на странице, его необходимо добавить
// к существующему элементу в DOM-дереве.
// ----------------------------------------------------------------------------------------
// Предположим, что добавляем к определенному элементу element, для этого есть способы :
// ----------------------------------------------------------------------------------------
// element.append(el1, el2, ...) – добавляет один или несколько элементов после всех детей элемента element.
// element.prepend(el1, el2, ...) – добавляет один или несколько элементов перед всеми детьми элемента element.
// element.after(el1, el2, ...) – добавляет один или несколько элементов после элемента element.
// element.before(el1, el2, ...) – добавляет один или несколько элементов перед элементом element.
// ----------------------------------------------------------------------------------------
// Во всех этих методах el – это элементы или строки, в любом сочетании и количестве.
// Строки добавляются как текстовые узлы.
// ----------------------------------------------------------------------------------------
// Если элемент для добавления уже находится в DOM, то он удаляется со своего старого места
// и добавляется в новое.
// Один и тот же элемент не может быть одновременно в двух местах !
// ----------------------------------------------------------------------------------------

const listUser = document.querySelector(".usernames");

// Добавление элемента списка в конец списка
const lastItem = document.createElement("li");
lastItem.textContent = "Poly-конец";
listUser.append(lastItem);

// Добавление элемента в начало списка
const firstItem = document.createElement("li");
firstItem.textContent = "Ajax-начало";
listUser.prepend(firstItem);

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Удаление элемента со страницы
// ========================================================================================
// elem.remove();
// ----------------------------------------------------------------------------------------
// Для того чтобы удалить элемент, используется метод remove().
// Он вызывается на элементе elem, который необходимо удалить.
// ----------------------------------------------------------------------------------------

const text1 = document.querySelector('.text');
text1.remove();

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Оптимизация работы с DOM
// ========================================================================================
// Современные браузеры пытаются оптимизировать процесс воспроизведения страницы
// без вмешательства разработчика. Однако, изменение DOM-дерева – это дорогостоящая операция,
// поэтому необходимо пытаться минимизировать количество обращений к DOM.
// ----------------------------------------------------------------------------------------
// Repaint – происходит, когда изменения коснулись стилей, влияющих на внешний вид элемента,
// но не на геометрию. К примеру opacity, background-color, visibility и outline.
// Браузер повторно создает элемент с учетом нового стиля. Также проверяется видимость
// других элементов, один или более могут оказаться скрытыми под изменившим внешний элемент.
// ----------------------------------------------------------------------------------------
// Reflow – происходит, когда изменения влияют на содержимое, структуру документа,
// положение элементов. Происходит перерасчет позиционирования и размеров, что приводит
// к повторному созданию части или всего документа. Изменение размера одного родительского
// контейнера повлияет на всех его детей и предков.
// Reflow оказывает значительно большее влияние на производительность, чем repaint.
// ----------------------------------------------------------------------------------------
// Все вышеперечисленные операции блокируют браузер.
// Страница не может выполнять никаких других операций в то время, когда происходит reflow или repaint.
// ----------------------------------------------------------------------------------------
// Причинами могут быть:
//      Манипуляции с DOM (сложение, удаление, изменение, перестановка элементов)
//      Изменение содержимого, в частности текста в полях форм
//      Расчет или изменение CSS-свойств
//      Добавление и удаление таблиц стилей
//      Манипуляции с атрибутом
//      Манипуляции с окном браузера (изменения размеров, прокрутка)
//      Активация псевдоклассов (например, ':hover')
// ----------------------------------------------------------------------------------------



// ========================================================================================
// Свойство innerHTML
// ========================================================================================
// Еще один способ создать DOM-элементы и поместить их в дерево – это использовать строки с тегами
// и позволить браузеру проделать всю тяжелую работу.
// У такого подхода есть свои плюсы и минусы.

// ========================================================================================
// innerHTML  -  Чтение
// ========================================================================================
// Свойство innerHTML сохраняет содержимое элемента, включая теги, в виде строки.
// Возвращаемое значение - это всегда валидный HTML-код.
// ----------------------------------------------------------------------------------------

const articleMy = document.querySelector(".article-my");
console.log(articleMy.innerHTML);
//      <h2 class="title-my">Article title</h2>
//      <p class="text-my">Lorem ipsum dolor <strong>Praesentium</strong> accusantium</p>
//      <a class="link-my" href="">Read more</a> 

const titleMy = document.querySelector(".article-my .title-my");
console.log(titleMy.innerHTML);
//       Article title

const textMy = document.querySelector(".article-my .text-my");
console.log(textMy.innerHTML);
//       Lorem ipsum dolor <strong>Praesentium</strong> accusantium

const linkMy = document.querySelector(".article-my .link-my");
console.log(linkMy.innerHTML);
//       Read more
// ----------------------------------------------------------------------------------------

// ========================================================================================
// innerHTML  -  Изменение
// ========================================================================================
// Свойство innerHTML доступно и для чтения, и для записи.
// Если записать в нее строчку с HTML-тегами, то браузер во время парсинга строчки
// превратит их в валидные элементы и добавит в DOM-дерево.
// ----------------------------------------------------------------------------------------

titleMy.innerHTML = 'Новый и <span class="accent">выделенный по классу</span> заголовок';

// ----------------------------------------------------------------------------------------
// Если в свойстве innerHTML записать пустую строку, содержимое элемента будет очищено.
// Это простой и быстрый способ удаления всего содержимого.
// ----------------------------------------------------------------------------------------
// При таком подходе, в отличие от document.createElement(), мы не получаем ссылку
// на созданный DOM-элемент.
// Это первый шаг на пути к шаблонизации – создание большого количества однотипной разметки
// с разными данными по заранее определенному шаблону.
// Например, как в списке товаров интернет магазина и т.д.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Однотипная (шаблонная) разметка
// ========================================================================================
// Однотипная (шаблонная) разметка создается из массива данных.
// Прием состоит в переборке этого массива и составлении одной строки с HTML-тегами,
// которую затем записываем в innerHTML элемента.
// ----------------------------------------------------------------------------------------

const technologies = ["HTML", "CSS", "JavaScript", "React", "Node"];
const listTech = document.querySelector(".list-tech");

// Переборка массива с помощью метода map и создание массива тегов li
// + объединение всех элементов массива в одну строку с помощью метода join() 
const markupTech = technologies
  .map((technology) => `<li class="list-tech-item">${technology}</li>`)
  .join("");

// Check the console, you'll see a single string with HTML tags
console.log(markupTech);
// <li class="list-tech-item">HTML</li>
// <li class="list-tech-item">CSS</li>
// <li class="list-tech-item">JavaScript</li>
// <li class="list-tech-item">React</li>
// <li class="list-tech-item">Node</li>

// Добавление во внутрь неномерованного списка - строки тегов одной операцией
listTech.innerHTML = markupTech;

// ----------------------------------------------------------------------------------------

// ========================================================================================
// innerHTML  -  Добавление
// ========================================================================================
// Изменение elem.innerHTML полностью удалит и снова создаст все потомки элемента elem.
// ----------------------------------------------------------------------------------------
// Если элемент поначалу не был пуст, то возникнут дополнительные затраты на сериализацию
// уже существующей разметки, а это плохо.
// ----------------------------------------------------------------------------------------
// Используйте свойство elem.innerHTML для добавления только тогда, когда элемент elem – пуст,
// или если нужно полностью заменить его содержимое.
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Метод insertAdjacentHTML()
// ========================================================================================
// Cовременный метод для добавления строки с HTML-тегами перед, после или внутрь элемента.
// Разрешает проблему innerHTML с повторной сериализацией содержимого элемента
// при добавлении разметки к уже существующей.
// ----------------------------------------------------------------------------------------
//      elem.insertAdjacentHTML(position, string);
// ----------------------------------------------------------------------------------------
// Аргумент position – это строка, позиция относительно элемента elem.
// Принимает одно из четырех значений :
//      "beforebegin"   - перед elem
//      "afterbegin"    – внутри elem, перед всеми детьми
//      "beforeend"     – внутри elem, после всех детей
//      "afterend"      - после elem
// ----------------------------------------------------------------------------------------
// "beforebegin" и "afterend" работают только тогда, когда elem уже находится в DOM-дереве.
// ----------------------------------------------------------------------------------------

const listHtml = document.querySelector(".list-html");

const newTechnologies = ["React", "TypeScript", "Node.js"];
const markupHtml = newTechnologies
  .map((technology) => `<li class="list-html-item new">${technology}</li>`)
  .join("");

listHtml.insertAdjacentHTML("beforeend", markupHtml);
listHtml.insertAdjacentHTML("beforebegin", "<h2>Новые технологии - вставленный заголовок</h2>");
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Подключение скриптов
// ========================================================================================
// Загрузка и исполнение скрипта, указанного в тезисе <script> без каких-либо атрибутов,
// блокируют обработку HTML-документа и построение DOM. Это проблема.
// ----------------------------------------------------------------------------------------
//      <script src="path-to-script.js"></script>
// Когда анализатор встречает такой тэг, обработка HTML-документа прекращается и начинается
// загрузка файла скрипта, указанного в атрибуте src.
// После загрузки скрипт выполняется, и только потом возобновляется обработка HTML.
// ----------------------------------------------------------------------------------------
// Это называется "блокирующий" скрипт.
// ----------------------------------------------------------------------------------------
// Атрибуты defer и async были введены, чтобы дать разработчикам возможность лучше
// контролировать способ загрузки скриптов и когда именно их выполнять.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Атрибут defer
// ========================================================================================
// <script defer src="path-to-script.js"></script>
// ----------------------------------------------------------------------------------------
// Атрибут defer указывает браузеру загружать файл скрипта в фоновом режиме,
// параллельно обработке HTML-документа и построению DOM.
// ----------------------------------------------------------------------------------------
// Скрипт будет исполнен только после того, как HTML-документ был обработан, а DOM построен.
// ----------------------------------------------------------------------------------------
// Такие скрипты не блокируют построение DOM-дерева и гарантированно выполняются
// в том порядке, в каком указаны в HTML-документе.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Атрибут async
// ========================================================================================
// <script async src="path-to-script.js"></script>
// ----------------------------------------------------------------------------------------
// Загрузка скрипта с атрибутом async не блокирует построение DOM,
// но выполняется сразу после загрузки.
// ----------------------------------------------------------------------------------------
// Это означает, что такие скрипты могут заблокировать построение DOM
// и выполняются в произвольном порядке.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// События
// ========================================================================================
// Событие – это сигнал от браузера о том, что на веб-странице что-то произошло.
// ----------------------------------------------------------------------------------------
// События используются для реакции на действия пользователя и выполнения кода,
// связанного с определенным событием.
// ----------------------------------------------------------------------------------------
// Существует множество видов событий: мыши, клавиатуры, элементов форм, загрузки изображений,
// буфера обмена, изменения стадии CSS анимации или перехода, изменения размеров окна и многие другие.
// ----------------------------------------------------------------------------------------
// Одно действие может вызвать несколько событий.
// Например, клик вызывает сначала mousedown, а затем mouseup и click.
// В тех случаях, когда одно действие генерирует несколько событий, их порядок фиксирован.
// То есть обработчики вызываются в порядке mousedown → mouseup → click.
// ----------------------------------------------------------------------------------------
// Для того чтобы элемент реагировал на действия пользователя, к нему необходимо добавить
// слушателя (обработчика) события.
// То есть функцию, которая будет вызвана, как только событие произошло.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод    addEventListener()
// ========================================================================================
// Добавляет слушателя события на элемент.
// ----------------------------------------------------------------------------------------
//      element.addEventListener(event, handler, options);
// ----------------------------------------------------------------------------------------
//      event   – ​​имя события, строка, например "click".
//      handler – колбек-функция, которая будет вызвана при наступлении события.
//      options – необязательный объект параметров с расширенными настройками.
// ----------------------------------------------------------------------------------------

// Поиск селектора для кнопки
const buttonMy = document.querySelector(".my-button");

// Слушатель событий
buttonMy.addEventListener("click", () => {
  console.log("Button was clicked - First function");
});

// ----------------------------------------------------------------------------------------
// Для колбека можно (и желательно) использовать отдельную функцию и передавать на нее ссылку.
// Именованая функция (функция с именем) увеличивает читабельность кода.
// ----------------------------------------------------------------------------------------

// Отдельная функция, которая вызываетс при возникновении события
const handleClick = () => {
  console.log("Button was clicked - Second function");
};
// Слушатель событий
buttonMy.addEventListener("click", handleClick);

// ----------------------------------------------------------------------------------------
// На одном элементе может находиться любое количество обработчиков событий,
// даже событий одного типа. Колбек-функции будут вызываться в порядке регистрации в коде.
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Метод  removeEventListener()
// ========================================================================================
// Удаляет события слушателя с элемента. Аргументы аналогичны методу addEventListener().
// ----------------------------------------------------------------------------------------
//      element.removeEventListener(event, handler, options);
// ----------------------------------------------------------------------------------------
// Для удаления нужно передать ссылку именно на ту колбек-функцию,
// которая была назначена в addEventListener().
// В таком случае, для колбеков используют отдельную функцию и передают ее по имени (ссылке).
// ----------------------------------------------------------------------------------------

// Удаление события слушателя (по функции handleClick)
buttonMy.removeEventListener("click", handleClick);

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Ключевое слово this
// ========================================================================================
// Если колбеком будет функция, использующая this, по умолчанию контекст внутри нее
// будет ссылаться на DOM-элемент, на котором висит слушатель.
// ----------------------------------------------------------------------------------------

const mango = {
  username: "Mango",
  showUsername() {
    console.log(this);
    console.log(`My username is: ${this.username}`);
  },
};

const btnView = document.querySelector(".btn-view");

// ✅ Работает, просто вызывает метод объекта 
// mango.showUsername(); 

// ❌ this будет ссылаться на button, если использовать  showUsername  как  callback
// btnView.addEventListener("click", mango.showUsername); // не работает - undefined

// ✅ Слушатель событий - Нужно привязывать контекст методов объекта
btnView.addEventListener("click", mango.showUsername.bind(mango));

// ----------------------------------------------------------------------------------------


// ========================================================================================
// Объект события
// ========================================================================================
// Чтобы обработать событие – недостаточно знать о том, что это клик или нажатие клавиши,
// могут потребоваться детали. К примеру, текущее значение текстового поля, элемент,
// на котором произошло событие, встроенные методы и другие.
// ----------------------------------------------------------------------------------------
// Каждое событие – это объект, содержащий информацию о деталях происшествия
// и автоматически передается первым аргументом в обработчик события. 
// ----------------------------------------------------------------------------------------
// Все события происходят из базового класса Event.
// ----------------------------------------------------------------------------------------

const handleClickEvent = event => {
    console.log('Событие - ', event);
    console.log("event: ", event);
    console.log("event type: ", event.type);
    console.log("currentTarget: ", event.currentTarget);
};

buttonMy.addEventListener("click", handleClickEvent);

// ----------------------------------------------------------------------------------------
// Параметр event – ​​это и есть объект события, который автоматически передается
// первым аргументом при вызове колбек-функции.
// ----------------------------------------------------------------------------------------
// Мы можем называть его как угодно, но, как правило, его объявляют как e, evt или event.
// ----------------------------------------------------------------------------------------
// Некоторые свойства объекта события:
//      event.type          – тип события.
//      event.currentTarget – элемент, на котором выполняется обработчик события.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Действия браузера по умолчанию
// ========================================================================================
// Некоторые события вызывают действие браузера, встроенное по умолчанию в качестве реакции
// на определенный тип события.
// Например, клик на ссылку инициирует переход на новый адрес, указанный в href,
// а отправка формы перезагружает страницу.
// Чаще это поведение нежелательно и его необходимо отменить.

// ========================================================================================
// Метод preventDefault()
// ========================================================================================
// Используется для отмены действия браузера по умолчанию объекта события .
// ----------------------------------------------------------------------------------------

const form = document.querySelector(".register-form");

form.addEventListener("submit", (event) => {

    //----------------------------------------------------------------------
    // Отмена действия по умолчанию - отправка формы и перезагрузка страницы
    //----------------------------------------------------------------------
    event.preventDefault();
    //----------------------------------------------------------------------

    console.log("currentTarget: ", event.currentTarget);

    // Деструктуризация свойств формы 
    const {
         elements: { username, password }
    } = event.currentTarget;
    
    console.log(username.value, password.value);

});

// ----------------------------------------------------------------------------------------

// ========================================================================================
// События клавиатуры
// ========================================================================================
// Существует два основных события клавиатуры: keydown и keyup.
// В отличие от других события клавиатуры обрабатываются на документе, а не на конкретном элементе.
// Объекты событий клавиатуры исходят из базового класса KeyboardEvent.
// ----------------------------------------------------------------------------------------
// Нажимая клавишу, сначала происходит keydown, после чего – keyup, когда клавишу отпустили.
// На практике преимущественно обрабатывают только событие keydown, поскольку оно происходит
// быстрее keyup, и пользователь раньше видит результат нажатия.
// ----------------------------------------------------------------------------------------
// События keydown и keyup срабатывают при нажатии любой клавиши,
// включая служебные (Ctrl, Shift, Alt, Escape и т.д.).
// ----------------------------------------------------------------------------------------
// Раньше было еще одно событие клавиатуры – keypress.
// Большинство постов на форумах и блогах все еще могут его использовать, но будьте осторожны –
// она устарела и поддержка в новых браузерах может прекратиться в любой момент.
// ----------------------------------------------------------------------------------------

    // document.addEventListener("keydown", event => {
    // console.log("Keydown:", event);
    // });

    // document.addEventListener("keyup", event => {
    // console.log("Keyup: ", event);
    // });

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Свойства key и code
// ========================================================================================
// Свойство key возвращает символ, сгенерированный нажатием клавиши, учитывая состояние
// клавиш-модификаторов, например Shift, а также текущий язык.
// ----------------------------------------------------------------------------------------
// Свойство code возвращает код физической клавиши на клавиатуре и не зависит от языка.
// ----------------------------------------------------------------------------------------

    // document.addEventListener("keydown", event => {
    // console.log("key:", event.key);
    // console.log("code:", event.code);
    // });

// ----------------------------------------------------------------------------------------
// Пример. Отслеживание событий клавиатуры находится на элементе document.
//         Напечатайте что-нибудь на клавиатуре и посмотрите результат.
// ----------------------------------------------------------------------------------------

    // const clearLogBtn = document.querySelector(".js-clear");
    // const logList = document.querySelector(".log-list");
    // let keypressCounter = 1;

    // console.log(clearLogBtn)

    // document.addEventListener("keydown", logMessage);
    // document.addEventListener("keyup", logMessage);
    // clearLogBtn.addEventListener("click", reset);

    // function logMessage({ type, key, code }) {
    // const markup = `<div class="log-item">
    //     <span class="chip">${keypressCounter}</span>
    //     <ul>
    //     <li><b>Event</b>: ${type}</li>
    //     <li><b>Key</b>: ${key}</li>
    //     <li><b>Code</b>: ${code}</li>
    //     </ul>
    // </div>`;

    // logList.insertAdjacentHTML("afterbegin", markup);

    // if (type === "keyup") {
    //     incrementKeypressCounter();
    // }
    // }

    // function reset() {
    // keypressCounter = 1;
    // logList.innerHTML = "";
    // }

    // function incrementKeypressCounter() {
    // keypressCounter += 1;
    // }
        
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Клавиши-модификаторы
// ========================================================================================
// Для обработки комбинации клавиш, например Ctrl+s или любой другой, на объекте события
// имеются свойства ctrlKey, altKey, shiftkey и metaKey, сохраняющие булевое значение,
// сигнализирующее о том, была ли зажата клавиша-модификатор.
// ----------------------------------------------------------------------------------------
// Некоторые комбинации клавиш могут конфликтовать с поведением обозревателя по умолчанию.
// Например, Ctrl+d или Command+d делает закладку.
// Необходимо стараться проектировать систему комбинаций страницы таким образом,
// чтобы она не пересекалась со встроенной в браузере.
// ----------------------------------------------------------------------------------------
// Но, по крайней мере, по умолчанию можно отменить, вызвав метод event.preventDefault().
// ----------------------------------------------------------------------------------------
// Не так давно вместо свойств key и code использовали свойство keyCode.
// Большинство постов на форумах и блогах все еще могут использовать ее,
// но будьте осторожны – она устарела, не используйте свойство keyCode.
// ----------------------------------------------------------------------------------------

//      document.addEventListener("keydown", event => {
//           event.preventDefault();
//           // Если нажата комбинация клавиш (Ctrl или Мета) + клавиша S - то вывод сообщения
//            if ((event.ctrlKey || event.metaKey) && event.code === "KeyS") {
//               console.log("Ctrl+s или Command+s combo");
//           }
//      });

// ----------------------------------------------------------------------------------------


// ========================================================================================
// События элементов форм
// ========================================================================================

// ========================================================================================
// Событие  submit
// ========================================================================================
// Отправка формы происходит во время клика по кнопке с атрибутом type="submit"
// или нажатием клавиши Enter, находясь в любом ее текстовом поле.
// ----------------------------------------------------------------------------------------
// Событие submit можно применить для валидации (проверки) формы перед отправкой,
// поскольку на объекте происшествия существует множество полезных свойств,
// связанных с элементами формы.
// ----------------------------------------------------------------------------------------
// submit формы перезагружает страницу, поэтому не забывайте отменять действие по умолчанию
// методом preventDefault().
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Свойство  elements  DOM-элемента формы содержит объект со ссылками на все его элементы,
// имеющие атрибут  name.
// ----------------------------------------------------------------------------------------
// Поэтому в примере мы получаем значение полей, обращаясь к login1.value и password1.value.
// ----------------------------------------------------------------------------------------

const registerForm = document.querySelector(".form1");

registerForm.addEventListener("submit", handleSubmit);

function handleSubmit(event) {

    // отменить действие по умолчанию
    event.preventDefault();
    
    const form = event.target;
    console.log('form', form);
    console.log('form.elements', form.elements);

    // Получаем значения полей из объекта  elements  по значению атрибута  name
    const login = form.elements.login1.value;
    const password = form.elements.password1.value;
  
    // Если пустое значение хотя бы одного поля, то сообщение и возврат на дополнительный ввод
  if (login === "" || password === "") {
    return console.log("Please fill in all the fields!");
  }

  console.log(`Login: ${login}, Password: ${password}`);
    
  form.reset();
}

// ----------------------------------------------------------------------------------------


// ========================================================================================
// Событие  change
// ========================================================================================
// Происходит после смены элемента формы.
// ----------------------------------------------------------------------------------------
// Для текстовых полей или textarea событие произойдет не на каждом вводе символа,
// а после потери фокуса, что не всегда удобно.
// ----------------------------------------------------------------------------------------
// Например, пока вы набираете что-либо в текстовом поле – событие отсутствует,
// но как только фокус пропал, произойдет событие change.
// ----------------------------------------------------------------------------------------
// Для других элементов, например, select, чекбоксов и радио-кнопок,
// событие change срабатывает сразу при выборе значения.
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Обратите внимание на полезные свойства при работе с элементом <select> в примере.
// Разберитесь, что сохраняется в свойствах value, selectedIndex и options.
// ----------------------------------------------------------------------------------------
// value - это значение атрибута value=""
// selectedIndex - индекс выбранного значения в массиве 
// options - массив значений option
// options[selectedOptionIndex].text - это текст, которым обозначается на странице выбранный option
// ----------------------------------------------------------------------------------------
const select = document.querySelector(".pizza-select");
const textOutput = document.querySelector(".text-output");
const valueOutput = document.querySelector(".value-output");

select.addEventListener("change", setOutput);

function setOutput(event) {
  const selectedOptionValue = event.currentTarget.value;
  const selectedOptionIndex = event.currentTarget.selectedIndex;
  const selectedOptionText =
    event.currentTarget.options[selectedOptionIndex].text;

    console.log('event.currentTarget.value = ', selectedOptionValue);
    console.log('event.currentTarget.selectedIndex = ', selectedOptionIndex);
    console.log('event.currentTarget.options', event.currentTarget.options);
    console.log('event.currentTarget.options[selectedOptionIndex].text = ', selectedOptionText)
    
  textOutput.textContent = selectedOptionText;
  valueOutput.textContent = selectedOptionValue;
}

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Событие  input
// ========================================================================================
// Происходит только на текстовых полях и textarea, и создается всякий раз
// при изменении значения элемента, не дожидаясь потери фокуса.
// ----------------------------------------------------------------------------------------
// На практике input – это самое главное событие для работы с текстовыми полями формы.
// ----------------------------------------------------------------------------------------

const textInput = document.querySelector(".text-input");
const output = document.querySelector(".output");

textInput.addEventListener("input", (event) => {
  output.textContent = event.currentTarget.value;
});

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Событие  focus  и  blur
// ========================================================================================
// Элемент получает фокус во время щелчка мыши или перехода клавишей Tab.
// ----------------------------------------------------------------------------------------
// Момент получения и потери фокуса очень важен, получая фокус, мы можем загрузить
// данные для автозаполнения, начать отслеживать изменения и т.д.
// ----------------------------------------------------------------------------------------
// При потере фокуса – проверить введенные данные.
// ----------------------------------------------------------------------------------------
// Во время фокусировки элемента происходит событие focus, а когда фокус исчезает,
// например пользователь кликает в другом месте экрана, происходит событие blur.
// ----------------------------------------------------------------------------------------
// Активировать или отменить фокус можно программно,
// вызвав в коде элемента одноименные методы focus() и blur().
// ----------------------------------------------------------------------------------------
// Фокус может быть только на одном элементе страницы за единицу времени и текущий элемент,
// на котором находится фокус, доступен как document.activeElement.
// ----------------------------------------------------------------------------------------
// Фокус может получить только интерактивный элемент
// ----------------------------------------------------------------------------------------
// Многие элементы не могут получить фокусировку. К примеру, если кликнуть по <div>,
// то фокусировка на нем не произойдет, потому что это не интерактивный элемент.
// ----------------------------------------------------------------------------------------

const textInput1 = document.querySelector(".text-input1");
const setFocusBtn = document.querySelector('[data-action="set"]');
const removeFocusBtn = document.querySelector('[data-action="remove"]');

// Слушатель события при нажатии на кнопку - Установить фокус
setFocusBtn.addEventListener("click", () => {
  textInput1.focus();
});

// Слушатель события при нажатии на кнопку - Убрать фокус
removeFocusBtn.addEventListener("click", () => {
  textInput1.blur();
});

// Слушатель события - получение фокуса на поле ввода
textInput1.addEventListener("focus", () => {
  textInput1.value = "This input has focus";
});

// Слушатель события - потеря фокуса на поле ввода
textInput1.addEventListener("blur", () => {
  textInput1.value = "";
});

// ----------------------------------------------------------------------------------------