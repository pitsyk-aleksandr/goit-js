// Модуль 5
// Ключевое слово this.
// Прототипы и классы.
// ****************************************************************************************

// Примеры из Видео

// ========================================================================================
// Ключевое слово this
// ========================================================================================
// Внутри функции можно использовать ключевое слово this.  Во время выполнения функции,
// в this записывается ссылка на объект, в контексте которого она была вызвана.
// Таким образом, в теле функции мы можем получить доступ к свойствам и методам этого объекта.
// ----------------------------------------------------------------------------------------

// Функция - это сложный тип (как объект).
// Функция передается по ссылке, как массивы и объекты.
// При передаче функции (либо присваивании переменной) - передается ссылка на функцию.
// ----------------------------------------------------------------------------------------
// this - это как локальная переменная, которая есть только внутри функции
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
// Контекст - это то, что вызвало, в контексте какого объекта вызывается функция
// ----------------------------------------------------------------------------------------
const fnA = function () {
    console.log('Привет !');
}
const fnB = fnA;
// Сравнение переменных, которым присвоена эта функция
console.log('fnA===fnB', fnA === fnB);      // fnA===fnB   true
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Основные правила (контекст this) :
// 1. Где и как была объявлена функция не имеет никакого влияния на контекст.
// 2. Контекст определяется в момент вызова функции, если он не привязан явно. 
//    Значение записывается в this в момент ВЫЗОВА ФУНКЦИИ.
// ----------------------------------------------------------------------------------------

// ВАРИАНТЫ:
// ----------------------------------------------------------------------------------------
// 1. Функция как метод объекта  -  в контексте вызывающего этот метод объекта
// ----------------------------------------------------------------------------------------
const user = {
    tag: 'San',
    showUserTag() {
        console.log('this - ',this);
        console.log('this.tag - ',this.tag);
    }
};

// Значение  this  присваивается в момен вызова функции - метода объекта
user.showUserTag();
// this - { tag: 'San', showUserTag: ƒ }
// this.tag -  San

//  this теперь  ссылается на тот объект, который вызвал функцию
//  в нашем конкретном случае - объект  user, который стоит перед точкой с вызовом метода.
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Если переменной присвоить функцию метода объекта и вызвать потом как отдельную функцию,
// то this будет undefined, так как функция будет вызвана без контеста (без объекта)
// ----------------------------------------------------------------------------------------
// Присваиваем переменной функцию
const unoShowUserTag = user.showUserTag; 
// Вызываем функцию без объекта
// unoShowUserTag();       // this - undefined + ошибка при поиске свойства tag....
// ----------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------
// 2. Вызов функции без контекства  -  в строгом режиме -  undefined
// ----------------------------------------------------------------------------------------
const foo = function() {
    console.log('foo -> this = ', this);
}
// Вызов функции foo
foo();  // foo -> this = undefined
// Буквально - НИКАКОЙ ОБЪЕКТ МЕНЯ НЕ ВЫЗЫВАЛ.
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// 3. Вызов функции как метод объекта, но объявлена как внешняя функция
// ----------------------------------------------------------------------------------------
// Объявляем внешнюю функцию
const showName = function() {
    console.log('this - ', this);
    console.log('this.name - ', this.name);
};
// Вызов функции вне объекта - вернет this - undefined - см. Вариант 2
// showName();  // + Ошибка - Cannot read properties of undefined (reading 'name')
// ----------------------------------------------------------------------------------------

// Объявляем объект guest
const guest = {
    name: "Alex",
};

// Делаем новой свойство для объекта guest и присваиваем ему имя внешней функции
// то есть ложим туда ссылку на внешнюю функцию
guest.showNameGuest = showName;

// Вызываем функцию по названию нового метода объекта.  Именно здеcь определяется значение this.
guest.showNameGuest(); 
// this -  {name: 'Alex', showNameGuest: ƒ}
// this.name -  Alex
// ----------------------------------------------------------------------------------------


// ----------------------------------------------------------------------------------------
// 4. Контекст в коллбек-функциях
// ----------------------------------------------------------------------------------------
// При передаче метода объекта, как коллбек - контекст НЕ сохраняется
const table = {
    tag: 'Белый',
    showUserTag() {
        console.log('this - ',this);
        console.log('this.tag - ',this.tag);
    }
};

// ----------------------------------------------------------------------------------------
const invokeAction = function (action) {
    // Вывод в консоль тела колбек-функции
    console.log(action);
    // Вызов колбек-функции
    // action();
};

// ----------------------------------------------------------------------------------------
// Вызов функции с колбек-функцией - мотодом объекта в аргументе
// При передаче метода объекта, как коллбек - контекст НЕ сохраняется
// ----------------------------------------------------------------------------------------
invokeAction(table.showUserTag);
// /ƒ showUserTag() {
//         console.log('this - ',this);
//         console.log('this.tag - ',this.tag);
// }

//  this - undefined

// Функция вызывается без контекста слева, поэтому this = undefined/
// ----------------------------------------------------------------------------------------
// Контекст - это то, что вызвало, в контексте какого объекта вызывается функция
// ----------------------------------------------------------------------------------------

// Тренировки по this

let counter = {
    value: 0,
    increment(value) {
        this.value += value;
    },
    decrement(value) {
        this.value -= value;
    }
}

let updateCounter = function(value, operation) {
    operation(value);
};

// updateCounter(10, counter.increment); // ОШИБКА, так как this - undefined
// ----------------------------------------------------------------------------------------
// При передаче метода объекта, как коллбек - контекст НЕ сохраняется !
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Разница между вызовом функции - в круглых скобках и без круглых скобок
// ----------------------------------------------------------------------------------------

const func = function () {
    return 5;
}
// ----------------------------------------------------------------------------------------
// Без круглых скобок = возвращает ссыдку на саму функцию - в консоль выведется тело
console.log(func);
    // ƒ () {
    //   return 5;
    //}
// ----------------------------------------------------------------------------------------  
// С круглыми скобками = возвращает результат работы функции - в консоль выведется return
console.log(func())     // 5
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// dir - выводит на консоль функцию как объект со всеми ее методами
console.dir(func)
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод функции - call
// ========================================================================================
// Позволяет взять произвольную функцию и принудительно вызвать ее в контексте какого-то объекта
// ----------------------------------------------------------------------------------------
// Позволяет ОДНОРАЗОВО вызвать функцию в привязке к определённому объекту
// ----------------------------------------------------------------------------------------
// Вызывает функцию "на месте", то есть здесь и сейчас
// ----------------------------------------------------------------------------------------
// Первым аргументом в методе call() стоит название объекта, в контексте которого вызывается функция
// Второй и последующий аргументы = это просто аргументы, которые будут переданы в функцию.
// Аргументы который переданы при вызове - в функции это просто перечень параметров
// ----------------------------------------------------------------------------------------

const ShowThisObj = function (x,y,z) {
    console.log('this Object - ', this);
    console.log('Аргументы - ', x,y,z);
};

const objA = {
    a: 1,
    b:2,
};
// ----------------------------------------------------------------------------------------

ShowThisObj.call(objA, 10, 20, 30);
        // this Object - {a: 1, b: 2}
        // Аргументы - 10, 20, 30  --- просто список
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод функции - apply
// ========================================================================================
// То же что и метод call, но аргументы при вызове функции передаются массивом
// Но массив аргументов который передан при вызове - в функции это просто перечень параметров
// ----------------------------------------------------------------------------------------
ShowThisObj.apply(objA, [10, 20, 30]);
        // this Object - {a: 1, b: 2}
        // Аргументы - 10, 20, 30 --- просто список
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Использование call(): (как вариант наследования)
// Можно написать одну функцию и использовать её для разных объектов в качестве метода
// ----------------------------------------------------------------------------------------
const changeColor = function (newColor) {
    this.color = newColor;
    console.log('Объект - ', this.name, 'Цвет - ', this.color);
};

const picture = {
    name: 'picture',
    color: 'black',
}
const hat = {
    name: 'hat',
    color: 'red',
}

changeColor.call(picture, 'orange'); // Объект -  picture Цвет -  orange
changeColor.call(hat, 'blue');       // Объект -  hat Цвет -  blue
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Метод bind
// ========================================================================================
// Позволяет сделать копию функции с НАВСЕГДА "привязанным" контекстом.
// Оригинальная функция НЕ изменяется
// ----------------------------------------------------------------------------------------
// Метод НЕ вызывается здесь и сейчас.
// У этой копии this ВСЕГДА будет ссылаться на "привязанный" объект
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Пример - привязка функции по изменению цвета к объекту hat
// ----------------------------------------------------------------------------------------
// Делаем копию функции с привязкой к объекту
const changeColorHat = changeColor.bind(hat);

// Вызываем функцию с изменением цвета
changeColorHat('green');    // Объект -  hat Цвет -  green
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Использование и применение метода bind()
// ========================================================================================
// Позволяет передавать метод объекта как колбек
// ----------------------------------------------------------------------------------------
counter = {
    value: 0,
    increment(value) {
        this.value += value;
    },
    decrement(value) {
        this.value -= value;
    }
}

updateCounter = function(value, operation) {
    operation(value);
};

// Привязываем функцию - метод объекта к самому объекту
// Эту функцию используем как колбек-функцию :

updateCounter(10, counter.increment.bind(counter)); 
console.log(counter);   // {value: 10, increment: ƒ, decrement: ƒ}

updateCounter(5, counter.decrement.bind(counter)); 
console.log(counter);   // {value: 5, increment: ƒ, decrement: ƒ}
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Прототип объекта
// ========================================================================================
// ----------------------------------------------------------------------------------------
// Пример. Создадим цепочку прототипов, 
// ObjectC - прототип для objectB, а objectB - прототип для objectA
// Создаем самый "нижний прототип"
// ----------------------------------------------------------------------------------------
const objectC = {
    c: 20,
};
console.log('objectC',objectC);   // {c: 20}

// ----------------------------------------------------------------------------------------
// Создаем объект objectB, для которого objectC будет прототипом.
// Используем метод Object.create(имя_объекта-прототипа)
// На каждом уровне вложенности – создаются ССЫЛКИ на объекты-прототипы
// ----------------------------------------------------------------------------------------
const objectB = Object.create(objectC);
console.log('objectB',objectB);   // {}

// ----------------------------------------------------------------------------------------
// Для objectB создаем новое свойство
// ----------------------------------------------------------------------------------------
objectB.b = 10;
console.log('objectB',objectB);  // {b: 10}

// ----------------------------------------------------------------------------------------
// Получение свойств для objectB
// ----------------------------------------------------------------------------------------
console.log(objectB.b); // 10 - собственное свойство
console.log(objectB.c); // 20 - свойство объекта-прототипа

// ----------------------------------------------------------------------------------------
// Создаем объект objectA, для которого objectB будет прототипом.
// Используем метод object.create(имя_объекта-прототипа)
// ----------------------------------------------------------------------------------------
const objectA = Object.create(objectB);
objectA.a = 5;
console.log('objectA', objectA);  // {a: 5}

// ----------------------------------------------------------------------------------------
// Попытка изменить значение свойства объекта-прототипа приведет к добавлению нового свойства
// в объект с новым значением, а значение свойства в объекте-прототипе останется БЕЗ ИЗМЕНЕНИЙ !
// ----------------------------------------------------------------------------------------
objectA.c = 1000;
console.log('objectA', objectA);  // {a: 5, c: 1000}
console.log('objectC', objectC);  // {c: 20}  - значение свойства в прототипе НЕ изменилось !

// ========================================================================================
// Метод  имя_объекта.hasOwnProperty(имя_свойства)
// ========================================================================================
// Проверяет, является ли указанное свойство собственным для вызывающего метод объекта.
// Возвращает true, если свойство - собственное
// ----------------------------------------------------------------------------------------
console.log(objectA.hasOwnProperty('a'));   // true
console.log(objectA.hasOwnProperty('b'));   // false

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Основы Объектно-ориентированного программирования :
// класс, экземпляр (объект), интерфейс
// ========================================================================================
// ----------------------------------------------------------------------------------------
// Функции - конструкторы :
//      Именование - ОБЯЗАТЕЛЬНО с большой буквы
//      Оператор new
//      Свойство Function.Prototype
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
// Функция-конструктор сама по себе ничего не делает
// Основную работу делает оператор new.
// Получаем объект myCar, который является экземпляром класса Car
// this - это объект, который создался при помощи оператора new
// ----------------------------------------------------------------------------------------
// Основные правила функции-констуктора :
// 1. Если функция вызывается через new - создается пустой объект.
// 2. Функция вызывается в контексте созданного объекта,
//    то есть в this записывается ссылка на него.
// 3. В свойство this.__proto__ записывается ссылка на объект Car.prototype,
//    то есть Car.prototype - это прототип будущего объекта (экземпляра)
// 4. Ссылка на объект возвращается в место вызова new Car.
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
// Именование - с большой буквы и в названии существительное (отвечает на вопрос - Что это? )
// ----------------------------------------------------------------------------------------
const Train = function (value) {
    this.a = value;
 };
// ----------------------------------------------------------------------------------------
// Делаем экземпляры машины по этому конструктору 
// ----------------------------------------------------------------------------------------
const myTrain1 = new Train(10);
console.log('myTrain1', myTrain1);  // Train {a: 10}
const myTrain2 = new Train(20);
console.log('myTrain2', myTrain2);  // Train {a: 20}

// ----------------------------------------------------------------------------------------
// Создаем конструктор для машины с передачей нескольких параметров
// Если нет параметров при вызове Car - в config - записываем пустой объект
// ----------------------------------------------------------------------------------------
// const Car = function(config = {}) {
//     console.log('config- ', config);
//     this.brand = config.brand;
//     this.model = config.model;
//     this.price = config.price;
// };

// ----------------------------------------------------------------------------------------
// Тот же конструктор, только с деструктуризацией параметров функции-конструктора
// + год выпуска будет присвоен всем новым экземплярам класса
// ----------------------------------------------------------------------------------------
const Car = function ({ brand, model, price } = {}) {

    // 2. Функция вызывается в контексте созданного объекта,
    //    то есть в this записывается ссылка на него.
    
    // Передаваемые свойства при создании экземпляра
    this.brand = brand;
    this.model = model;
    this.price = price;

    // год выпуска будет присвоен всем новым экземплярам класса
    this.year = 2025;

    // -------------------------------------------------------------------------------
    // + добавляем функцию изменения цены, которая будет методом для всех экземпляров
    //   но это будет КОПИЯ функции, а не ссылка - поэтому лучше использовать Car.prototype
    //          this.changePrice = function (newPrice) {
    //                   this.price = newPrice;
    //          }
    // -------------------------------------------------------------------------------

    // 3. В свойство this.__proto__ записывается ссылка на объект Car.prototype,
    //    то есть Car.prototype - это прототип будущего объекта (экземпляра)

    // 4. Ссылка на объект возвращается в место вызова new Car.
};

// ----------------------------------------------------------------------------------------
// Добавляем новый метод в прототип Car
// ----------------------------------------------------------------------------------------
Car.prototype.sayHi = function (hi) {
    console.log('sayHi -> this', this);
    console.log(hi);
}

// ----------------------------------------------------------------------------------------
// Добавляем новый метод в прототип Car
// ----------------------------------------------------------------------------------------
Car.prototype.changePrice = function (newPrice) {
    this.price = newPrice;
}

// ----------------------------------------------------------------------------------------
// Создаем экземпляр машины с определенными свойствами
// 1. Если функция вызывается через new - создается пустой объект.
// ----------------------------------------------------------------------------------------
const myCar1 = new Car({
    brand: 'Audi',
    model: 'Q3',
    price: 35000,
})
console.log('myCar1 - ', myCar1);  // Car {brand: 'Audi', model: 'Q3', price: 35000, year: 2025}

const myCar2 = new Car({
    brand: 'BMW',
    model: 'X6',
    price: 50000,
})
console.log('myCar2 - ', myCar2); // Car {brand: 'BMW', model: 'X6', price: 50000, year: 2025}

const myCar3 = new Car({
        brand: 'Audi',
    model: 'Q7',
    price: 60000,
})
console.log('myCar3 - ', myCar3); // Car {brand: 'Audi', model: 'Q7', price: 60000, year: 2025}

// ----------------------------------------------------------------------------------------
// Вызов метода изменения цены для машины 3
// ----------------------------------------------------------------------------------------
myCar3.changePrice(62000);
console.log('myCar3 - ', myCar3); // Car {brand: 'Audi', model: 'Q7', price: 62000, year: 2025}

// ----------------------------------------------------------------------------------------
// Вызов метода, который находится в прототипе
// ----------------------------------------------------------------------------------------
myCar1.sayHi('Привет, машина 1 !');

// ----------------------------------------------------------------------------------------
// Пример. Создать конструктор для пользователей и эмейлом и паролем
// ----------------------------------------------------------------------------------------
const User = function ({ email, password } = {}) {
    this.email = email;
    this.password = password;
};
// Новый метод - в прототип
User.prototype.changeEmail = function (newEmail) {
    this.email = newEmail;
 };
// Создание экземпляра
const user1 = new User({
    email: '11@mail.com',
    password: 12345,
});

console.log(user1); // User {email: '11@mail.com', password: 12345}

// Вызов метода по смене email у пользователя user1
user1.changeEmail('newMy@mail.net');

console.log(user1); // User {email: 'newMy@mail.net', password: 12345}
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Статические свойства и методы
// ========================================================================================
// Используются для вспомогательных вещей :
//  - хранения констант
//  - хранения утилитных методов (для экземпляров класса)
// ----------------------------------------------------------------------------------------
// Статические свойства и методы доступны только на самом конструкторе
// На конструктор можно добавить что-то, что не будет создаваться в экземпляре...
// ----------------------------------------------------------------------------------------
// В статических методах не нужен this. this ссылается на сам контструктор.
// ----------------------------------------------------------------------------------------

// Создание статического свойства
User.message = 'Я статическое свойство. Меня нет на экземплярах или в прототипе';
console.dir(User);  // Свойство message есть только в User !!!

// Создание экземпляра
const user2 = new User({
    email: '222@mail.com',
    password: 2222,
});
console.log(user2);  // User {email: '222@mail.com', password: 2222} // Нет нигде свойства message

// Создание статического метода
// Принимает объект и логинит информацию из объекта - выводит в консоль
User.logInfo = function (obj) {
    console.log(obj);
    console.log('Почта - ', obj.email);
    console.log('Пароль - ', obj.password);
}

// Вызов статического метода (нигде ни в экземпляре, ни в прототипе нет статических свойств и методов)
User.logInfo(user2); // User {email: '222@mail.com', password: 2222}

// Примеры из конструктора Math
console.log(Math.round(5.1));   // утилитный метод
console.log(Math.PI);           // константа


// ========================================================================================
// Примеры использования прототипов, классов, плагинов
// ========================================================================================
// Плагин - готовая библиотека, инструмент для решения какой-то задачи.
// ----------------------------------------------------------------------------------------

// Создание счетчика-планина - в counter-plugin.js




// ========================================================================================
// Классы
// ========================================================================================
// Это новый способ записывать функцию-конструктор с уже готовым прототипом.
// Более чистый и ясный синтаксис
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Объявление класса
// ========================================================================================
// Ключевое слово  class
// Имя класса (с большой буквы)
// Тело класса (в фигурных скобках)
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Конструктор
// ========================================================================================
// При создании класса обязательно в теле метод constructor
// Метод constructor выполняется автоматически при создании экземпляра класса
// Метод constructor  - это аналог функции-constructor
// ----------------------------------------------------------------------------------------
//       ВСЁ, что идет на экземпляр - записываем в constructor
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод класса
// ========================================================================================
// Внутри класса объявляется функция, которая является методом класса
// (по аналогии с тем старым объявлением через .prototype. )
// ----------------------------------------------------------------------------------------
//       ВСЁ, что идет на prototype - записываем в методы
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Статические свойства и методы - которые НЕ привязываются к экземпляру класса
// ========================================================================================
// Начинается с ключевого слова static, затем имя свойства (или метода) и значение
// Обычно пишут перед объявлением метода constructor
// Статические свойства (и методы) помещаются в консоли в  constructor
// Используется для хранения констант, методов - утилит, которые не идут на экземпляр,
// а помогают делать вспомогательные вещи
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Приватные свойства
// ========================================================================================
// Приватные свойства объявляются вне конструктора и имя начинается на #
// Приватные свойства ставятся на экземпляр при создании экземпляра класса
// Доступ к приватному свойству - только через метод класса
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Синтаксис публичных свойств и методы класса
// ========================================================================================
// Публичные свойства объявляются вне конструктора.

// ========================================================================================
// Геттеры и сеттеры
// ========================================================================================
// Они заменяют собой прямое обращение и изменение какого-то свойства.
// Это упрощение интерфейса для работы со свойствами.
// Используются тогда, когда в программе есть необходимость читать и изменять значение свойства
// ----------------------------------------------------------------------------------------
// Геттер и сеттер не могут называться одинаково с тем свойством, еоторое они описывают.
// В нашем случае в начале имени самого свойства конструктора поставим подчеркивание,
// Но можно делать абсолютно разными именами (в геттере и для физического свойства объекта)
// ----------------------------------------------------------------------------------------
// Когда читается свойство, то вызывается геттер
// Когда что-то записывается в свойство - вызывается сеттер
// Визуально идёт как будто обращение к свойству напрямую.
// Обычно геттеры и сеттеры делаются на каждое свойство класса.
// Геттеры и сеттеры лежать в прототипе __proto__.
// ----------------------------------------------------------------------------------------
// Геттеры - методы класса, которые предназначены для получения значения свойств.
// Начинается с ключевого слова  get
// ----------------------------------------------------------------------------------------
// Сеттеры - методы класса, которые предназначены для изменения значения свойств.
// Начинается с ключевого слова  set
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Пример.
// ----------------------------------------------------------------------------------------
// Создание класса для автобусов
class Autobus {

    // Статические свойства
    static description = 'Класс описывает автобусы';
    static A = 'Статическое свойство';

    // Статические методы
    static objectLog = function (busObject) {
        console.log('Инфо по машине - ',busObject);
    };

    // Приватные свойства объявляются вне конструктора 
    #testPrivate = 'test';

    // Публичные свойста
    mySuperBonus = 5;

    // Метод-конструктор
    constructor({ brand, model, price } = {}) { 
        console.log('Выполняется constructor при создании экземпляра класса');
        // Передаваемые свойства при создании экземпляра
        this.brand = brand;
        this._model = model;
        this.price = price;
    };

    // // Обычный метод класса для получения значения свойства this.model
    // getModel() {
    //     return this._modelmodel;
    // }

    // Геттер для получения значения свойства this.model - 
    get model() {
        return this._model;
    };

    // // Обычный метод класса для изменения значения свойства this.model
    // setModel(newModel) {
    //     this._model = newModel;
    // }

    // Сеттер для изменения значения свойства this.model
    set model(newModel) {
        this._model = newModel;
    }

    // Метод класса - изменение цены
    changePrice(newPrice) {
        this.price = newPrice;
    };

    // Метод класса - получение приватного свойства
    getTest() {
        console.log(this.#testPrivate);
        return this.#testPrivate;
    };
    

};

// ----------------------------------------------------------------------------------------
// Создание экземпляра класса с помощью оператора new
const bus1 = new Autobus({ brand: 'BMW', model: 'Q7', price: 100000, });

// ----------------------------------------------------------------------------------------
// Вывод в консоль экземпляра класса
console.log('bus1 - ', bus1);   // Autobus {brand: 'BMW', model: 'Q7', price: 100000}

// ========================================================================================
// Object.getPrototypeOf(имя_экземпляра_класса)
// ========================================================================================
// Возвращает методы и свойства прототипа __proto__
// ----------------------------------------------------------------------------------------
// Получение информации о прототипе объекта (экземпляре класса)
console.log(Object.getPrototypeOf(bus1));
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Вызов метода класса - начинается с имени объекта (имя_экземпляра_класса)
// Изменение цены объекта-экземпляра класса
// ----------------------------------------------------------------------------------------
bus1.changePrice(90000);
console.log('bus1 - ', bus1);   // Autobus {brand: 'BMW', model: 'Q7', price: 90000}

// ----------------------------------------------------------------------------------------
// Вызов статического свойства и метода
// ----------------------------------------------------------------------------------------
console.log('static property A - ', Autobus.A);  // static property A - Статическое свойство
console.log(Autobus.description);                // Класс описывает автобусы
Autobus.objectLog(bus1);  // Инфо по машине - Autobus {brand: 'BMW', model: 'Q7', price: 90000}
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Вызов Метода класса - получение приватного свойства
// ----------------------------------------------------------------------------------------
bus1.getTest();     // test
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Вызов геттера при чтении свойства (само свойство в конструкторе с подчеркиванием _model)
// ----------------------------------------------------------------------------------------
console.log(bus1.model);    // Q7

// ----------------------------------------------------------------------------------------
// Вызов cеттера при изменении и записи свойства
// ----------------------------------------------------------------------------------------
bus1.model = 'Q11';
console.log(bus1.model);        // Q11


// ========================================================================================
// Наследование   - extends + super()
// ========================================================================================
// Создается базовый класс - родительский
// Класс-ребенок наследует все свойства и все методы класса-родителя
// ----------------------------------------------------------------------------------------
// Наследование базового класса происходит при объявлении нового класса :
// Синтаксис :     class  Имя_нового_класса  extends  Имя_базового_класса  {}
// ----------------------------------------------------------------------------------------
// Если класс-ребенок наследует класс-родитель, то в конструкторе класса-ребенка
// первым оператором нужно вызвать конструктор класса-родителя
// Синтаксис :  super();
// Это просто конструктор класса-родителя и мы его запускаем с параметрами
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Связь между классами "под капотом"
// ========================================================================================
// Все свойства прототипа - ложатся в объект
// Все методы прототипа - вызываются по ссылке
// ========================================================================================
// __proto__ - это свойство
// prototype - это объект
// ----------------------------------------------------------------------------------------
// В свойство __proto__ экземпляра ложится ссылка на Warrior.prototype
// vasya.__proto                === Warrior.prototype             // true
// ----------------------------------------------------------------------------------------
// В свойство __proto__ Warrior.prototype ложится ссылка на Hero.prototype
// Warrior.prototype.__proto__  === Hero.prototype                // true
// ----------------------------------------------------------------------------------------
// В свойство __proto__ Hero.prototype лежит ссылка на Object.prototype
// Hero.prototype.__proto__     === Object.prototype                // true
// ========================================================================================


// ----------------------------------------------------------------------------------------
// Базовый класс
// ----------------------------------------------------------------------------------------
class Hero {

    // Имя и опыт героя
    // В параметрах - деструктуризируем объект, который приходит
    // и присваиваем переменным дефолтные значения (значения "по умолчанию")
    constructor({ name = 'hero', xp = 0, }={}) { 
        this.name = name;
        this.xp = xp;
    };

    // Метод добавления опыта
    addXp(amount) {
        console.log(`${this.name} получает ${amount} баллов опыта`);
        this.xp = this.xp + amount;
    };
    
};


// ----------------------------------------------------------------------------------------
// Новый класс Warrior наследует класс Hero и его методы (extend + super())
// ----------------------------------------------------------------------------------------
class Warrior extends Hero {
    // В параметрах - деструктуризируем объект, который приходит при создании нового экземпляра
    // и разбиваем объект на нужные свойства для этого класса и другие значения (...)
    // которые вернем в супер-конструктор родительского класса
    // В параметрах указываем ={}, чтобы в любом случае мы получили объект значений, хоть и пустой
    constructor({ weapon, ...heroProperties } = {}) {
        // Запускается конструктор для Hero
        super(heroProperties);
        this.weapon = weapon;
    };
    // Метод атаки
    attack() {
        console.log(`Воин ${this.name} атакует, используя ${this.weapon}`);
        // Добавляется опыт
        this.addXp(100);
    }
};

// ----------------------------------------------------------------------------------------
// Новый Воин
// ----------------------------------------------------------------------------------------
const vasya = new Warrior({ name:'Вася', xp:100, weapon:'меч'});
console.log('Воин - ',vasya);
vasya.attack();
console.log('Воин - ', vasya);
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Новый класс Ara наследует класс Warrior -> Hero и его методы (extend + super())
// ----------------------------------------------------------------------------------------
class Ara extends Warrior {
    constructor({ krik, ...heroProperties } = {}) {
        // Запускается конструктор для Warrior
        super(heroProperties);

        this.krik = krik;
    };
    
};

// ----------------------------------------------------------------------------------------
// Новый Ara
// ----------------------------------------------------------------------------------------
const pet = new Ara({ name:'Петя', xp:1000, weapon:'алебарда', krik: 'ААААААААААА'});
console.log('Ara - ',pet);
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Новый класс Mage наследует класс Hero и его методы (extend + super())
// ----------------------------------------------------------------------------------------
class Mage extends Hero {
    constructor({ spells, ...heroProperties } = {}) {
        // Запускается конструктор для Hero
        super(heroProperties);
        this.spells = spells;
    };

    // Метод молитвы мага
    doSpell(indexSpells) {
        console.log(`Маг ${this.name} молится, используя ${this.spells[indexSpells]}`);
        // Добавляется опыт
        this.addXp(50);
    };
};

// ----------------------------------------------------------------------------------------
// Новый Маг
// ----------------------------------------------------------------------------------------
const ded = new Mage({ name: 'Дед', xp:100, spells:['руки вверх','заклинание']});
console.log('Маг - ',ded);
ded.doSpell(0);
ded.doSpell(1);
console.log('Маг - ', ded);
// ----------------------------------------------------------------------------------------