// Модуль 5
// Ключевое слово this.
// Прототипы и классы.
// ****************************************************************************************

// Примеры из конспекта

// ========================================================================================
// Ключевое слово this
// ========================================================================================
// Внутри функции можно использовать ключевое слово this.  Во время выполнения функции,
// в this записывается ссылка на объект, в контексте которого она была вызвана.
// Таким образом, в теле функции мы можем получить доступ к свойствам и методам этого объекта.
// ----------------------------------------------------------------------------------------
let petya = {
  username: "Petya",
  showName() {
    console.log(this.username);
  },
};
petya.showName();  // Petya
// ----------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------- 
// Методы getAuthors і addAuthor - это функции (методы объекта), которые вызываются в контексте
// объекта bookShelf. Во время их выполнения в this записывается ссылка на объект bookShelf 
// и мы можем обратиться к его свойствам и методам.
// ----------------------------------------------------------------------------------------
const bookShelf = {
    authors: ["Бернард Корнуелл", "Роберт Шекли"],
    // Получение ссылки на свойство authors выбранного объекта
    getAuthors() {
        return this.authors;
    },
    // Метод добавления автора книги 
    addAuthor(authorName) {
        this.authors.push(authorName);
    },
};
// ----------------------------------------------------------------------------------------
console.log(bookShelf.getAuthors()); // ["Бернард Корнуелл", "Роберт Шекли"]
bookShelf.addAuthor("Ли Танит");
console.log(bookShelf.getAuthors()); // ["Бернард Корнуелл", "Роберт Шекли", "Ли Танит"]
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Правила определения  this
// ========================================================================================
// Значение контента внутри функции (не стрелочной) определяются не на момент её создания,
// а на момент вызова.
// То есть значение  this  определяется тем, как вызывается функция, а не где она была объявлена.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// this в глобальной области видимости
// ========================================================================================
// В глобальной области видимости, если скрипт выполняется НЕ в строгом режиме, 
// this ссылается на объект  window.
// В строгом режиме значение  this, в глобальной области видимости, будет undefined.
// ----------------------------------------------------------------------------------------
function foo() {
  console.log(this);
}
foo(); // window без "use strict" и undefined с "use strict"
// ----------------------------------------------------------------------------------------

// ========================================================================================
// this в методе объекта
// ========================================================================================
// Если функция была вызвана как метод объекта, то контекст будет ссылаться на объект,
// частью которого есть метод.
// ----------------------------------------------------------------------------------------
petya = {
  username: "Petya",
  showThisObj() {
    console.log(this);
  },
  showName() {
    console.log(this.username);
  },
};
// Вызов методов объекта
petya.showThisObj();   // {username: "Petya", showThis: ƒ, showName: ƒ}
petya.showName();   // 'Petya'
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Как сделать внешнюю функцию методом объекта ?
// ========================================================================================
// Порядок работы :
// 1. Объявляем функцию в глобальной видимости. Внутри функции используем слово  this.
// 2. Создаем любой объект с любыми свойствами.
// 3. Для этого объекта создаём свойство любого названия (которое будет являться методом объекта)
//    и в значении этого свойства ставим название внешней функции.
// 4. Теперь вызываем эту функцию (по названию свойства), как метод объекта.
// ----------------------------------------------------------------------------------------

// 1. Объявляем функцию в глобальной видимости. Внутри функции используем слово  this.
function showThis() {
  console.log("this in showThis: ", this);
}

// Вызываем функцию в глобальном контексте для проверки
showThis(); // this in showThis: undefined.

// 2. Создаем любой объект с любыми свойствами.
let user = {
  username: "Mango",
};

// 3. Для этого объекта создаём свойство любого названия (которое будет являться методом объекта)
//    и в значении этого свойства ставим название внешней функции.
// Записываем ссылку на функцию в свойство объекта.
// Обратите внимание - это НЕ вызов - нет круглых скобок ()
user.showContext = showThis;

// Вызываем функцию в контекксте объекта, как метод объекта.
// this будет указывать на текущий объект, в контексте которого осуществляется вызов,
// а не на глобальный объект.
// Указываются все свойства текущего объекта
user.showContext(); // this in showThis: {username: "Mango", showContext: ƒ}

// ----------------------------------------------------------------------------------------

// ========================================================================================
// this в callback-функциях
// ========================================================================================
// Передавая методы объекта как колбек-функции, контекст не сохраняется.
// Колбек-функция - это ссылка на метод, которая присваивается как значение параметра,
// который вызывается БЕЗ объекта.
// ----------------------------------------------------------------------------------------
let customer = {
  firstName: "Jacob",
  lastName: "Mercer",
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

// Внешняя функция с колбеком
function makeMessage(callback) {
  // callback() - это вызов метода getFullName без объекта
  console.log(`Обрабатываем заявку от ${callback()}.`);
}

//    makeMessage(customer.getFullName); // Будет ОШИБКА в вызове функции !!!

// ----------------------------------------------------------------------------------------

// ========================================================================================
// this в стрелочных функциях
// ========================================================================================
// Стрелочные функции не имеют своего  this.
// В отличие от обычных функций, изменить значение this внутри стрелки после объявления - нельзя.
// ----------------------------------------------------------------------------------------
// Контентв внутри стрелки определяется местом её объявления, а не вызова.
// и ссылаетяс на контент родительской функции.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Методы функций
// ========================================================================================
// Бывают ситуации, когда функцию необходимо вызвать в контекстве объекта, при этом
// функция не является его методом. Для этого у функций есть методы call, apply и bind.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод call()  ----      call = вызвать (англ.)
// ========================================================================================
// СИНТАКСИС :
// foo.call(obj, arg1, arg2, ...)
// ----------------------------------------------------------------------------------------
// Метод call вызовет функцию  foo  таким образом, что в this будет ссылка на объект obj,
// а также передаст аргументы arg1, arg2 и т.д..
// ----------------------------------------------------------------------------------------

function greetGuest1(greeting) {
  console.log(`${greeting}, ${this.username}.`);
}

let mango = {
  username: "Манго",
};
let poly = {
  username: "Поли",
};

greetGuest1.call(mango, "Ласкаво просимо"); // Ласкаво просимо, Манго.
greetGuest1.call(poly, "З прибуттям"); // З прибуттям, Поли.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод apply​()  ----      apply​ = применить (англ.)
// ========================================================================================
// Метод apply​() - это аналог метода call(), за исключением того, что синтаксис передачи
// аргументов требует не перечисление, а массив, даже если аргумент всего один.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
// foo.call(obj, arg1, arg2, ...)
// foo.apply(obj, [arg1, arg2, ...])
// ----------------------------------------------------------------------------------------
// Метод apply() вызовет функцию  foo таким образом, что в this будет ссылка на объект obj,
// а также передаст элементы массива как отдельные аргументы arg1, arg2 и т.п.
// ----------------------------------------------------------------------------------------

function greetGuest2(greeting, smile) {
  console.log(`${greeting}, ${this.username}. ${smile}`);
}

mango = {
  username: "Манго",
};
poly = {
  username: "Полі",
};

greetGuest2.apply(mango, ["Добро пожаловать ", "Хи-хи-хи"]); // Добро пожаловать , Манго. Хи-хи-хи
greetGuest2.apply(poly, ["С прибытием ", "Ха-ха-ха"]); // С прибытием , Полі. Ха-ха-ха
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод bind() ----      bind = связать (англ.)
// ========================================================================================
// Методы call и apply вызывают функцию «на месте», то есть сразу.
// Но в случае колбек - функций, когда необходимо не сразу вызывать функцию, а передать
// ссылку на неё, причём со связанным контентом, используется метод  bind.
// ----------------------------------------------------------------------------------------
// СИНТАКСИС :
// foo.bind(obj, arg1, arg2, ...)
// ----------------------------------------------------------------------------------------
// Метод bind создаёт и возвращает копию функции   foo  со связанным контекстом  obj
// и аргументами arg1, arg2 и т.п.
// Создаётся копия функции, которую можно передать куда угодно и вызвать когда угодно.
// ----------------------------------------------------------------------------------------

// Объявление функции  greet
function greet(clientName) {
  return `${clientName}, добро пожаловать в «${this.service}».`;
}

// Объект  steam
const steam = {
  service: "Steam",
};
// Создается копия функции  greet  с привязкой к объекту  steam
const steamGreeter = greet.bind(steam);
steamGreeter("Манго"); // "Манго, добро пожаловать в  «Steam»."

// Объект  gmail
const gmail = {
  service: "Gmail",
};

// Создается копия функции  greet  с привязкой к объекту  gmail
const gmailGreeter = greet.bind(gmail);
gmailGreeter("Поли"); // "Поли, добро пожаловать в  «Gmail»."

// ----------------------------------------------------------------------------------------

// ========================================================================================
// bind() и методы объекта​
// ========================================================================================
// В случае передачи метода объекта как  колбек-функции  , контекст не сохраняется. 
// Колбек - это ссылка на метод, которая присваивается как значение параметра, 
// который вызывается без объекта.
// ----------------------------------------------------------------------------------------
customer = {
  firstName: "Jacob",
  lastName: "Mercer",
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

function makeMessageOk(callback) {
  // callback() - это вызов метода getFullName но без объекта
  console.log(`Обробляємо заявку від ${callback()}.`);
}

// ----------------------------------------------------------------------------------------
// Значение  this в методе getFullName, которое вызывается как колбек-функции callback(),
// будет undefined.
// Обращаясь к свойствам firstName і lastName, будет ошибка, так как undefined - это не объект.
// ----------------------------------------------------------------------------------------

// makeMessageOk(customer.getFullName); // Будет ошибка в момент вызова функции

// ----------------------------------------------------------------------------------------
// Метод bind используется для привязки контекста, передавая метод объекта как колбек-функции.
// Передим колбеком не оригинальний метод  getFullName,
// а его копию с привязанным контекстом объекта  customer.
// ----------------------------------------------------------------------------------------

makeMessage(customer.getFullName.bind(customer)); // Обрабатываем заявку от Jacob Mercer.

// ----------------------------------------------------------------------------------------


// ========================================================================================
// Процедурное программирование
// ========================================================================================
// Это набор не связанных явно функций и переменных для хранения и оработки информации.
// Этот подход простой и прямолинейный , и может использоваться для задач,
// в которых нет тесно связанных сущностей (данных и функций для их обработки).
// ----------------------------------------------------------------------------------------
// ПРИМЕР процедурного программирования
// ----------------------------------------------------------------------------------------
let baseSalary = 30000;
let overtime = 10;
let rate = 20;

const getWage = (baseSalary, overtime, rate) => {
  return baseSalary + overtime * rate;
};

getWage(baseSalary, overtime, rate);
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Объектно-ориентированное программирование (ООП)
// ========================================================================================
// Это методология, которая описиывает программу как совокупность объектов, каждый из которых
// данные (свойства) и методв работы для взаимодействия с ними.
// ----------------------------------------------------------------------------------------
// ПРИМЕР объектно-ориентированного программирования
// ----------------------------------------------------------------------------------------
let employee = {
  baseSalary: 30000,
  overtime: 10,
  rate: 20,
  getWage() {
    return this.baseSalary + this.overtime * this.rate;
  },
};

employee.getWage();
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Основные понятия ООП
// ========================================================================================
// ООП - это подход к программированиб как к моделированию, которое решает основное задание -
// структурирование информации с точки зрения управляемости, облегчая контроль процесса моделирования.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Сущности ООП
// ========================================================================================
// Представляем, что мы проектируем автомобиль.
// У него будут корпус, двигатель, 4 колеса, бензобак и т.д.
// АВтомобиль должен иметь возможность заводиться, увеличивать или уменьшать скорость и т.п.
// Мы знаем как взаимодействуют между собой разные части машины (двигатель - колеса и т.п.).
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Класс
// ========================================================================================
// Мы описываем все запчасти и то, каким образом запчасти взаимодействуют между собой
// И что должен делать водитель, чтобы автомобиль затормозил, включил фары и т.д.
// Результатом этой работы будет определенный эскиз (шаблон, схема).
// Ми только что сделали то, что в ООП называют классом.
// ----------------------------------------------------------------------------------------
// Класс - способ описания сущности, который определяет состояние и поведение, которое
// зависит от состояния, а также правила взаимдействия с этой сущностью.
// ----------------------------------------------------------------------------------------
// В нашем примере, КЛАСС определяет СУЩНОСТЬ - АВТОМОБИЛЬ.
// СВОЙСТВА КЛАССА - двигатель, колеса, фары и т.д.
// МЕТОДЫ КЛАССА - будут действия : открыт двери, завести двигатель, увеличить скорость и т.д.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Экземпляр класса
// ========================================================================================
// Мы спроектировали чертежи, и автомобили, разработанные на их основании - сходят с конвейера.
// Каждый из них повторяет чертежи, все системы работают так, как мы спроектировали,
// но каждый автомобиль - уникальный.
// Они все имеют номер кузова и двигателя, но сами эти номера - разные.
// Автомобили отличаются цветом кузова, оформлением салона и т.д.
// Эти автомобили - это экземпляры класса.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Интерфейс
// ========================================================================================
// Когда мы подходим садимся а руль автомобиля - есть определенный набор элементов управления,
// с которым мы можем взаимодействовать.
// ----------------------------------------------------------------------------------------
// ИНТЕРФЕЙС - это набор свойств и методов классов, доступных для использования
// в работе с экземпляром класса.
// ----------------------------------------------------------------------------------------
// ИНТЕРФЕЙС описывает класс, четко определяя все возможные действия над ним.
// Хороший пример интерфейса - панель приборов автомобиля, которая позволяет вызывать методы
// типа увеличения скорости, торжожения, поворота, переключения передач, включения фар и т.п.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Прототипное наследование
// ========================================================================================
// ООП в JavaScript построено на прототипном наследовании.
// Объекты можно организовать в цепочки таким образом, чтобы осуществлять автоматический
// поиск свойства, не найденного в одном объекто -  в другом объекте.
// Связующим звеном выступает специальное скрытое свойство [[Prototype]],
// которое в консоли браузера отображается как  __proto__.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Прототип объекта
// ========================================================================================
// Метод Object.create(obj) создает и возвращает новый объект, связывая его с объектом  obj.
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Объект-прототип
// ----------------------------------------------------------------------------------------
let animal = {
  legs: 4,
};

// ----------------------------------------------------------------------------------------
// Создание нового объекта на базе объекта-прототипа
// ----------------------------------------------------------------------------------------
let dog = Object.create(animal);
dog.name = "Манго";

// ----------------------------------------------------------------------------------------
// Объект, на который указывает ссылка в __proto__, называется прототипом.
// В нашем примере объект  animal  - это прототип для объекта dog. 
// ----------------------------------------------------------------------------------------
console.log(dog); //                    { name: 'Манго', __proto__: animal }

// ----------------------------------------------------------------------------------------
// Метод  isPrototypeOf()  проверяет, является ли объект animal прототипом для dog
// и возвращает  true  или  false.
console.log(animal.isPrototypeOf(dog)); // true

// ----------------------------------------------------------------------------------------
// Обращение dog.name работает определенным образом - возвращает собственное свойство name объекта dog. 
// ----------------------------------------------------------------------------------------
console.log(dog.hasOwnProperty("name")); // true
console.log(dog.name); // 'Манго'

// ----------------------------------------------------------------------------------------
// Обращаясь к dog.legs, интерпретатор ищет свойство legs в объекте dog, не находит 
// и продолжает поиск в объекте по ссылке  з dog.__ proto__, 
// то есть, в нашем конкретном случае, в объекте  animal  - своём прототипе.
// ----------------------------------------------------------------------------------------
console.log(dog.hasOwnProperty("legs")); // false
console.log(dog.legs); // 4
// ----------------------------------------------------------------------------------------

// ========================================================================================
// ПРОТОТИП - это резервное хранилище свойств и методов объекта, которе автоматически
// используется во время их поиска.
// Объект, который выступает прототипом, может иметь свой прототип, следуюзий - свой и так далее.
// Поиск свойства выполняется до первого совпадения
// Интерперетатор ищет свойство по имени в объекте, если не находит, то обращается к свойству
// __proto__, то есть переходит по ссылке к объекту-прототипу, а затем - к прототипу прототипа.
// Если интерпретатор дойдет до конца цепи и не найдет свойства с таким именем, то вернёт undefined.
// ----------------------------------------------------------------------------------------
// В спецификации свойство  __proto__ показана как [[Prototype]]. В этом случае важны
// двойные квадратные скобки, они указывают на то, что это внутреннее, служебное свойство.
// ========================================================================================

// ========================================================================================
// Метод obj.hasOwnProperty(prop)
// ========================================================================================
// Метод obj.hasOwnProperty(prop), возвращает true, если свойство  prop принадлежит объекту obj,
// н не его прототипу, в противном случае возвращает   false.
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Цикл for...in НЕ различает свойства объекта и его прототипа.
// ----------------------------------------------------------------------------------------
animal = { eats: true };
dog = Object.create(animal);
dog.barks = true;
// Выводим все свойства объекта  dog  через цикл  for...in
for (const key in dog) {
  console.log(key); // barks, eats
}
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Метод Object.keys(obj)
// ========================================================================================
// Метод Object.keys(obj) возвращает массив только собственных скойств (ключей) объекта obj,
// поэтому на практике используют именно его, а не for...in.
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Объект-прототип
// ----------------------------------------------------------------------------------------
animal = {
  eats: true,
};

// ----------------------------------------------------------------------------------------
// Создание нового объекта dog  на базе объекта-прототипа  animal
// ----------------------------------------------------------------------------------------
dog = Object.create(animal);

// ----------------------------------------------------------------------------------------
// Присваивание собственного свойства (ключа) для объекта  dog
// ----------------------------------------------------------------------------------------
dog.barks = true;

// ----------------------------------------------------------------------------------------
// Метод Object.keys(obj) возвращает массив только собственных скойств (ключей) объекта dog
// ----------------------------------------------------------------------------------------
const dogKeys = Object.keys(dog);
console.log(dogKeys); // ['barks']
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Классы
// ========================================================================================
// ----------------------------------------------------------------------------------------
// Синтаксис литерала объекта позволяет создать только один объект.
// Часто необходимо создать много обнотипных объектов с одинаковым набором свойств.
// но разными значениями этих свойств и методамидля взаимодействия с ними.
// Всё это необходимо делать динамически, во время выполнения программы.
// Для этого используют классы - специальный синтаксис объявления функции для создания объектов.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Объявление класса
// ========================================================================================
// Объявление класса начинается с ключевого слова class, после которого стоит имя класса
// и фигурные скобки - его тело.
// Классы принято называть с большой буквы, а в названии отображать тип объекта, который создается.
// ----------------------------------------------------------------------------------------
// Метод построения класса зависит от того, что вам необходимо
// В нашем случае класс - это пользователь, поэтому добавляем в класс поля для имени и почты.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Конструктор класcа
// ========================================================================================
// Для инициализации єкземпляра в классе есть метод constructor. Если он не объявлен -
// создаётся конструктор по умолчанию - пустая функция, которая не изменяет экземпляр.
// ----------------------------------------------------------------------------------------
// const User {
//     // Синтаксис объявления метода класса
//   constructor(name, email) {
//     // Инициализация свойств экземпляра
//     this.name = name;
//     this.email = email;
//   }
// };

// ----------------------------------------------------------------------------------------
// Результат вызова new User() - это объект, который называется экземпляром класса,
// потому что содержит данные и поведение, которые описываются классом.
// ----------------------------------------------------------------------------------------
// const pet = new User("Петя", "pet@mail.com");
// console.log(pet); // User {name: 'Петя', email: 'pet@mail.com'}

// const vas = new User("Вася", "vas@mail.com");
// console.log(vas); // User {name: 'Вася', email: 'vas@mail.com'}
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Вызов класса с оператором new приводит к созданию нового объекта и вызову конструктора
// в контексте этого объекта.
// То есть this внутри конструктора будет ссылаться на вновь созданный объект.
// Это позволяет добавлять каждому объекту свойства с одинаковыми именами, но разными значениями.
// ----------------------------------------------------------------------------------------
// Свойства name и email называются публичными свойствами, потому что они будут собственными
// свойствами объекта-экземпляра и к ним можно будет получить доступ, обратившись через точку.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Объект параметров
// ========================================================================================
// Класс может принимать огромное количество входных данных для параметров будущего объекта.
// Поэтому, к ним можно применить паттерн «Объект параметров», передавая один объект
// с логически именуемыми свойствами, вместо несвязанного набора аргументов.
// ========================================================================================

// const User {
//     // Деструктуризуємо об'єкт
//     constructor({ name, email}) {
//     this.name = name;
//     this.email = email;
//   }
// };

// const mango = new User({
//   name: "Манго",
//   email: "mango@mail.com",
// });
// console.log(mango); // { name: "Манго", email: "mango@mail.com" }

// const poly = new User({
//   name: "Поли",
//   email: "poly@mail.com",
// });
// console.log(poly); // { name: "Поли", email: "poly@mail.com" }

// ========================================================================================
// Методы класса
// ========================================================================================
// Для работы со свойствами будущего экземпляра используются методы класса – функции,
// которые будут доступны экземпляру в его прототипе.
// class User {
//     // Деструктуризуем объект
//   constructor({ name, email }) {
//     this.name = name;
//     this.email = email;
//   }

//   // Метод getEmail
//   getEmail() {
//     return this.email;
//   }

//   // Метод changeEmail
//   changeEmail(newEmail) {
//     this.email = newEmail;
//   }
// }

// const aleksandr = new User({
//    name: "Aleksandr",
//    email: "aleks@mail.com",
//  });

// console.log(aleksandr);     // User {name: 'Aleksandr', email: 'aleks@mail.com'}
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Приватные свойства
// ========================================================================================
// Инкапсуляция – это концепция, позволяющая скрыть внутренние детали класса.
// ----------------------------------------------------------------------------------------
// Пользователь класса должен получать доступ только к публичному интерфейсу –
// набору публичных свойств и методов класса.
// ----------------------------------------------------------------------------------------
// В классах инкапсуляция реализуется приватными свойствами,
// доступ к которым можно получить только внутри класса.
// ----------------------------------------------------------------------------------------
// Предположим, что почта пользователя должна быть недоступна для прямогоизменения
// снаружи, то есть - приватной.
// Добавляя к имени свойства символ #, мы делаем его приватным.
// Объявление приватного свойства до его инициализации в конструкторе – обязательно.
// ----------------------------------------------------------------------------------------

// class User {
//   // Необязательное объявления публичных свойств
//   name;
//   // Обязательное объявления приватных свойств
//   #email;

//   constructor({ name, email }) {
//     this.name = name;
//     this.#email = email;
//   }

//   getEmail() {
//     return this.#email;
//   }

//   changeEmail(newEmail) {
//     this.#email = newEmail;
//   }
// }

// const vova = new User({
//   name: "Вова",
//   email: "vova@mail.com",
// });

// // Изменение почты
// vova.changeEmail("vova@supermail.com");

// // Получение значения почты через метод
// console.log(vova.getEmail());      // vova@supermail.com

// Получение значения почты напрямую
// console.log(vova.#email);       // Будет ошибка, #email - это приватное свойство

// ----------------------------------------------------------------------------------------
// Методы класса могут быть приватными, то есть доступны только в теле класса.
// Для этого перед их именем необходимо поставить символ #.
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Геттеры и сеттеры
// ========================================================================================
// Геттеры и сеттеры – это более короткий синтаксис объявления методов для взаимодействия со свойствами.
// Геттер и сеттер имитируют обычное публичное свойство класса,
// но позволяют изменять другие свойства более удобным способом.
// ----------------------------------------------------------------------------------------
// Геттер выполняется при попытке получить значение свойства, а сеттер – при попытке его изменить.
// ----------------------------------------------------------------------------------------
// Геттеры и сеттеры уместно использовать для простых операций чтения и изменения значения свойств,
// особенно приватных, как их публичный интерфейс.
// Для работы со свойством, который хранит массив или объект, они не подойдут.
// ----------------------------------------------------------------------------------------

// class User {
//   #email;

//   constructor({ name, email }) {
//     this.name = name;
//     this.#email = email;
//   }

//   // Геттер email
//   get email() {
//     return this.#email;
//   }

//   // Сеттер email
//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// ----------------------------------------------------------------------------------------
// Мы объявили геттер и сеттер email, поставив перед именем свойства ключевые слова get и set.
// Внутри этих методов мы либо возвращаем значение приватного свойства #email,
// либо изменяем его значение.
// ----------------------------------------------------------------------------------------
// Геттер и сеттер используются в паре и должны называться одинаково.
// ----------------------------------------------------------------------------------------

// mango = new User({ name: "Манго", email: "mango@mail.com" });
// // Использование геттера
// console.log(mango.email); // mango@mail.com
// // Использование сеттера
// mango.email = "mango@supermail.com";
// // Использование геттера
// console.log(mango.email); // mango@supermail.com

// ----------------------------------------------------------------------------------------
// Обращаясь к mango.email, вызывается геттер get email() {...} и выполняется его код.
// При попытке записи mango.email="mango@supermail.com" вызывается сеттер set email(newEmail) {...}
// и строка "mango@supermail.com" будет являться значением параметра newEmail.
// ----------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------
// Преимущество в том, что это методы, а значит, во время записи можно выполнить дополнительный код,
// например, с любыми проверками, в отличие от выполнения этой операции непосредственно со свойством.
// ----------------------------------------------------------------------------------------
// Пример - измененный сеттер

// set email(newEmail) {
//   if(newEmail === "") {
//     console.error("Ошибка! Почта не может быть пустой строкой !");
//     return;
//   }

//   this.#email = newEmail;
// }
// ----------------------------------------------------------------------------------------

// ========================================================================================
// Статические свойства
// ========================================================================================
// Помимо публичных и приватных свойств будущего экземпляра, в классе можно объявить его собственные
// свойства, доступные только классу, но не его экземплярам – статические свойства (static).
// Они полезны для хранения информации, относящейся к классу.
// ----------------------------------------------------------------------------------------
// Статические характеристики объявляются в теле класса.
// Перед именованием свойства добавляется ключевое слово static.
// ----------------------------------------------------------------------------------------
// Статические свойства также могут быть приватными, то есть доступными только внутри класса.
// Для этого имя свойства должно начинаться с символа #, так же как и приватные свойства.
// Обращение к приватному статическому свойству вне тела класса вызовет ошибку.
// ----------------------------------------------------------------------------------------
// Добавим классу Пользователь приватное свойство role - его роль, определяющая набор прав,
// например, администратор, редактор, обычный пользователь и т.д.
// Возможные роли пользователей будем сохранять как статическое свойство Roles – объект со свойствами.
// ----------------------------------------------------------------------------------------

// class User {
//   // Объявление и инициализация статического свойства
//   static Roles = {
//     ADMIN: "admin",
//     EDITOR: "editor",
//   };

//   #email;
//   #role;

//   constructor({ email, role }) {
//     this.#email = email;
//     this.#role = role;
//   }

//   get role() {
//     return this.#role;
//   }

//   set role(newRole) {
//     this.#role = newRole;
//   }
// }

// mango = new User({
//   email: "mango@mail.com",
//   role: User.Roles.ADMIN,
// });

// console.log(mango.Roles); // undefined
// console.log(User.Roles); // { ADMIN: "admin", EDITOR: "editor" }

// console.log(mango.role); // "admin"
// mango.role = User.Roles.EDITOR;
// console.log(mango.role); // "editor"
// ----------------------------------------------------------------------------------------


// ========================================================================================
// Статические методы
// ========================================================================================
// В классе можно объявить не только методы будущего экземпляра, а также методы, доступные
// только классу – статические методы, которые могут быть как публичные, так и приватные.
// ----------------------------------------------------------------------------------------
// Синтаксис объявления аналогичен статическим свойствам, за исключением того, что значением будет метод.
// ----------------------------------------------------------------------------------------
// Особенность статических методов состоит в том, что при их вызове ключевое слово this
// ссылается на сам класс. Это означает, что статический метод может получить доступ 
// к статическим свойствам класса, но не к свойствам экземпляра. 
// Логично, потому что статические методы вызывает сам класс, а не его экземпляры.
// ----------------------------------------------------------------------------------------

// class User {
//   static #takenEmails = [];

//   static isEmailTaken(email) {
//     return User.#takenEmails.includes(email);
//   }

//   #email;

//   constructor({ email }) {
//     this.#email = email;
//     User.#takenEmails.push(email);
//   }
// }

// // Создание экземпляра класса
// mango = new User({ email: "mango@mail.com" });

// // Проверка статическим методом на наличие  email  в массиве - статическом свойстве 
// console.log(User.isEmailTaken("poly@mail.com"));        // false
// console.log(User.isEmailTaken("mango@mail.com"));       // true

// ----------------------------------------------------------------------------------------

// ========================================================================================
// Наследование классов
// ========================================================================================
// Ключевое слово  extends  позволяет реализовать наследование классов, когда один класс
// (дочерний, производный) наследует свойства и методы другого класса (родительского).
// ----------------------------------------------------------------------------------------
// В выражении class Child extends Parent дочерний класс Child наследует (расширяет)
// от родительского класса Parent.
// Это означает, что мы можем объявить базовый класс, который сохраняет общие характеристики
// и методы для группы производных классов, которые наследуют свойства и методы родительского,
// но также добавляют свои уникальные.
// ----------------------------------------------------------------------------------------
    
// class Child extends Parent {
//   // ...
// }

// ----------------------------------------------------------------------------------------
// Например, в приложении есть пользователи с разными ролями - администратор, контент менеджер и т.д.
// У каждого типа пользователя есть набор общих характеристик, например почта и пароль,
// но также есть и уникальные.
// ----------------------------------------------------------------------------------------
// Создав независимые классы для каждого типа пользователя, мы получим дублирование общих
// свойств и методов, и, если необходимо изменить, например название свойства, придется
// проходить по всем классам, а это неудобно и требует много времени.
// ----------------------------------------------------------------------------------------
// Вместо этого можно создать общий класс User, который будет сохранять набор общих свойств и методов,
// после чего создать классы для каждого типа пользователя, которые наследуют от класса User.
// При необходимости изменить что-либо общее, достаточно будет изменить только код класса User.
// ----------------------------------------------------------------------------------------

// class User {
//   #email;

//   constructor(email) {
//     this.#email = email;
//   }

//   get email() {
//     return this.#email;
//   }

//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// class ContentEditor extends User {
//   // Тіло класу ContentEditor
// }

// const editor = new ContentEditor("mango@mail.com");
// console.log(editor); // { email: "mango@mail.com" }
// console.log(editor.email); // "mango@mail.com"

// ----------------------------------------------------------------------------------------
// Класс ContentEditor наследует от класса User его конструктор, геттер и сеттер email,
// а также одноименное публичное свойство. Важно помнить, что приватные свойства и методы
// родительского класса не наследуется дочерним классом.
// ----------------------------------------------------------------------------------------
  
// ========================================================================================
// Конструктор дочернего класса
// ========================================================================================
// Прежде всего в конструкторе дочернего класса необходимо вызвать специальную функцию
// super(аргументы) – это псевдоним конструктора родительского класса. В противном случае,
// при попытке обратиться к  this  в конструкторе дочернего класса, возникнет ошибка.
// При вызове конструктора родительского класса передаем необходимые ему аргументы
// для инициализации свойств.
// ----------------------------------------------------------------------------------------

// class User {
//   #email;

//   constructor(email) {
//     this.#email = email;
//   }

//   get email() {
//     return this.#email;
//   }

//   set email(newEmail) {
//     this.#email = newEmail;
//   }
// }

// class ContentEditor extends User {
//   constructor({ email, posts }) {
//     // Вызов конструктора родительского класса User
//     super(email);
//     this.posts = posts;
//   }
// }

// const editor = new ContentEditor({ email: "mango@mail.com", posts: [] });
// console.log(editor); // { email: 'mango@mail.com', posts: [] }
// console.log(editor.email); // 'mango@mail.com'
// ----------------------------------------------------------------------------------------



// ========================================================================================
// Методы дочернего класса
// ========================================================================================
// В дочернем классе можно объявлять методы, которые будут доступны только его экземплярам.
// ----------------------------------------------------------------------------------------

class User {
  #email;

  constructor(email) {
    this.#email = email;
  }

  get email() {
    return this.#email;
  }

  set email(newEmail) {
    this.#email = newEmail;
  }
}

class ContentEditor extends User {
  constructor({ email, posts }) {
    super(email);
    this.posts = posts;
  }

  addPost(post) {
    this.posts.push(post);
  }
}

const editor = new ContentEditor({ email: "mango@mail.com", posts: [] });
console.log(editor); // { email: 'mango@mail.com', posts: [] }
console.log(editor.email); // 'mango@mail.com'
// Добавляем новый пост в массив в класс ContentEditor
editor.addPost("post-1");
console.log(editor.posts); // ['post-1']

// ----------------------------------------------------------------------------------------








